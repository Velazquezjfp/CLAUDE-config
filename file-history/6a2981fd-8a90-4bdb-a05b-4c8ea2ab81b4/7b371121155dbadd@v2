"""
Regions router - Full CRUD for regions table
Connects to EXTERNAL database (data tables)
"""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text
from typing import List

from database import get_external_db


router = APIRouter(prefix="/regions", tags=["Regions"])


@router.get("/", response_model=List[Region])
async def list_regions(
    db: AsyncSession = Depends(get_external_db),
):
    """
    List all regions
    """
    try:
        query = text("""
            SELECT region_id, region_name, region_code, created_at, updated_at
            FROM regions
            ORDER BY region_name
        """)

        result = await db.execute(query)
        rows = result.fetchall()

        return [dict(row._mapping) for row in rows]

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching regions: {str(e)}",
        )


@router.get("/{region_id}", response_model=Region)
async def get_region(
    region_id: int,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Get a single region by ID
    """
    try:
        query = text("""
            SELECT region_id, region_name, region_code, created_at, updated_at
            FROM regions
            WHERE region_id = :region_id
        """)

        result = await db.execute(query, {"region_id": region_id})
        row = result.fetchone()

        if not row:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Region with ID {region_id} not found",
            )

        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching region: {str(e)}",
        )


@router.post("/", response_model=Region, status_code=status.HTTP_201_CREATED)
async def create_region(
    region: RegionCreate,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Create a new region
    """
    try:
        # Check if region_name already exists
        check_query = text("SELECT region_id FROM regions WHERE region_name = :region_name")
        check_result = await db.execute(check_query, {"region_name": region.region_name})
        if check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Region with name {region.region_name} already exists",
            )

        insert_query = text("""
            INSERT INTO regions (region_name, region_code)
            VALUES (:region_name, :region_code)
            RETURNING region_id, region_name, region_code, created_at, updated_at
        """)

        result = await db.execute(
            insert_query,
            {
                "region_name": region.region_name,
                "region_code": region.region_code,
            },
        )

        await db.commit()
        row = result.fetchone()
        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating region: {str(e)}",
        )


@router.put("/{region_id}", response_model=Region)
async def update_region(
    region_id: int,
    region: RegionUpdate,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Update an existing region
    """
    try:
        # Check if region exists
        check_query = text("SELECT region_id FROM regions WHERE region_id = :region_id")
        check_result = await db.execute(check_query, {"region_id": region_id})
        if not check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Region with ID {region_id} not found",
            )

        # Build UPDATE clause dynamically
        update_fields = []
        params = {"region_id": region_id}

        if region.region_name is not None:
            update_fields.append("region_name = :region_name")
            params["region_name"] = region.region_name

        if region.region_code is not None:
            update_fields.append("region_code = :region_code")
            params["region_code"] = region.region_code

        if not update_fields:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="No fields to update",
            )

        update_query = text(f"""
            UPDATE regions
            SET {', '.join(update_fields)}
            WHERE region_id = :region_id
            RETURNING region_id, region_name, region_code, created_at, updated_at
        """)

        result = await db.execute(update_query, params)
        await db.commit()

        row = result.fetchone()
        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error updating region: {str(e)}",
        )


@router.delete("/{region_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_region(
    region_id: int,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Delete a region
    """
    try:
        # Check if region exists
        check_query = text("SELECT region_id FROM regions WHERE region_id = :region_id")
        check_result = await db.execute(check_query, {"region_id": region_id})
        if not check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Region with ID {region_id} not found",
            )

        delete_query = text("DELETE FROM regions WHERE region_id = :region_id")
        await db.execute(delete_query, {"region_id": region_id})
        await db.commit()

        return None

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error deleting region: {str(e)}",
        )
