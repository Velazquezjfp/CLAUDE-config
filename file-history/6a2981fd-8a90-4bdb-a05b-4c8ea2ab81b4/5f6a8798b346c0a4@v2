"""
Demands List router - Read access for demands_list table with pagination
Connects to EXTERNAL database (data tables)
Note: Historical BSA demand records - primarily read-only access
"""
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text
from typing import Optional
from datetime import date
import math

from database import get_external_db
from models import PaginatedResponse


router = APIRouter(prefix="/demands-list", tags=["Demands List"])


@router.get("/", response_model=PaginatedResponse)
async def list_demands_list(
    page: int = Query(1, ge=1, description="Page number"),
    per_page: int = Query(50, ge=1, le=200, description="Items per page"),
    bsa_id: Optional[str] = Query(None, description="Filter by BSA ID"),
    assignment_status: Optional[str] = Query(None, description="Filter by assignment status"),
    branch: Optional[str] = Query(None, description="Filter by branch"),
    start_date: Optional[date] = Query(None, description="Filter by start date (from)"),
    end_date: Optional[date] = Query(None, description="Filter by end date (to)"),
    db: AsyncSession = Depends(get_external_db),
):
    """
    List all historical demand records with pagination and optional filters.
    Data comes from external database.
    """
    try:
        offset = (page - 1) * per_page

        # Build WHERE clause dynamically
        where_clauses = []
        params = {"limit": per_page, "offset": offset}

        if bsa_id:
            where_clauses.append("bsa_id = :bsa_id")
            params["bsa_id"] = bsa_id

        if assignment_status:
            where_clauses.append("assignment_status = :assignment_status")
            params["assignment_status"] = assignment_status

        if branch:
            where_clauses.append("branch = :branch")
            params["branch"] = branch

        if start_date:
            where_clauses.append("shift_start_time::date >= :start_date")
            params["start_date"] = start_date

        if end_date:
            where_clauses.append("shift_finish_time::date <= :end_date")
            params["end_date"] = end_date

        where_sql = f"WHERE {' AND '.join(where_clauses)}" if where_clauses else ""

        # Count total
        count_query = text(f"SELECT COUNT(*) as total FROM demands_list {where_sql}")
        count_result = await db.execute(count_query, params)
        total = count_result.scalar()

        # Fetch demands_list records
        query = text(f"""
            SELECT
                id, bsa_id, task_name, assignment_status,
                resource_category, resource_category_group,
                technical_service, branch,
                shift_start_time, shift_finish_time, shift,
                start_location, end_location,
                start_location_code, end_location_code,
                people_needed, personnel, required_qualifications,
                work_type, work_operation_type1, work_operation_type2,
                responsible_person, isp_amgt, psp, priority, locked,
                assigned_resources, ir_er, comments,
                created_at, created_by, updated_at, updated_by
            FROM demands_list
            {where_sql}
            ORDER BY id DESC
            LIMIT :limit OFFSET :offset
        """)

        result = await db.execute(query, params)
        rows = result.fetchall()

        demands = [dict(row._mapping) for row in rows]

        total_pages = math.ceil(total / per_page) if total > 0 else 0

        return PaginatedResponse(
            total=total,
            page=page,
            per_page=per_page,
            total_pages=total_pages,
            data=demands,
        )

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching demands list: {str(e)}",
        )


@router.get("/{demand_id}")
async def get_demand_list_item(
    demand_id: int,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Get a single historical demand record by ID.
    Data comes from external database.
    """
    try:
        query = text("""
            SELECT
                id, bsa_id, task_name, assignment_status,
                resource_category, resource_category_group,
                technical_service, branch,
                shift_start_time, shift_finish_time, shift,
                start_location, end_location,
                start_location_code, end_location_code,
                people_needed, personnel, required_qualifications,
                work_type, work_operation_type1, work_operation_type2,
                responsible_person, isp_amgt, psp, priority, locked,
                assigned_resources, ir_er, comments,
                created_at, created_by, updated_at, updated_by
            FROM demands_list
            WHERE id = :demand_id
        """)

        result = await db.execute(query, {"demand_id": demand_id})
        row = result.fetchone()

        if not row:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Demand list item with ID {demand_id} not found",
            )

        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching demand list item: {str(e)}",
        )


@router.get("/bsa/{bsa_id}")
async def get_demands_list_by_bsa(
    bsa_id: str,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Get all historical demand records for a specific BSA ID.
    Data comes from external database.
    """
    try:
        query = text("""
            SELECT
                id, bsa_id, task_name, assignment_status,
                resource_category, resource_category_group,
                technical_service, branch,
                shift_start_time, shift_finish_time, shift,
                start_location, end_location,
                start_location_code, end_location_code,
                people_needed, personnel, required_qualifications,
                work_type, work_operation_type1, work_operation_type2,
                responsible_person, isp_amgt, psp, priority, locked,
                assigned_resources, ir_er, comments,
                created_at, created_by, updated_at, updated_by
            FROM demands_list
            WHERE bsa_id = :bsa_id
            ORDER BY id
        """)

        result = await db.execute(query, {"bsa_id": bsa_id})
        rows = result.fetchall()

        return [dict(row._mapping) for row in rows]

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching demands list by BSA ID: {str(e)}",
        )
