"""
Regions router - Full CRUD for regions table
Connects to EXTERNAL database (data tables)
"""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text
from typing import List

from database import get_external_db


router = APIRouter(prefix="/regions", tags=["Regions"])


@router.get("/")
async def list_regions(
    db: AsyncSession = Depends(get_external_db),
):
    """
    List all regions.
    Data comes from external database.
    """
    try:
        query = text("""
            SELECT region_id, region_name, region_code,
                   created_at, created_by, updated_at, updated_by
            FROM regions
            ORDER BY region_name
        """)

        result = await db.execute(query)
        rows = result.fetchall()

        return [dict(row._mapping) for row in rows]

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching regions: {str(e)}",
        )


@router.get("/{region_id}")
async def get_region(
    region_id: int,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Get a single region by ID.
    Data comes from external database.
    """
    try:
        query = text("""
            SELECT region_id, region_name, region_code,
                   created_at, created_by, updated_at, updated_by
            FROM regions
            WHERE region_id = :region_id
        """)

        result = await db.execute(query, {"region_id": region_id})
        row = result.fetchone()

        if not row:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Region with ID {region_id} not found",
            )

        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching region: {str(e)}",
        )


@router.post("/", status_code=status.HTTP_201_CREATED)
async def create_region(
    region: dict,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Create a new region in external database.
    Required fields: region_name
    """
    try:
        # Validate required fields
        if "region_name" not in region or not region["region_name"]:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Missing required field: region_name",
            )

        # Check if region_name already exists
        check_query = text("SELECT region_id FROM regions WHERE region_name = :region_name")
        check_result = await db.execute(check_query, {"region_name": region["region_name"]})
        if check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Region with name {region['region_name']} already exists",
            )

        insert_query = text("""
            INSERT INTO regions (region_name, region_code, created_by)
            VALUES (:region_name, :region_code, :created_by)
            RETURNING region_id, region_name, region_code,
                      created_at, created_by, updated_at, updated_by
        """)

        result = await db.execute(
            insert_query,
            {
                "region_name": region.get("region_name"),
                "region_code": region.get("region_code"),
                "created_by": region.get("created_by", "api"),
            },
        )

        await db.commit()
        row = result.fetchone()
        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating region: {str(e)}",
        )


@router.put("/{region_id}")
async def update_region(
    region_id: int,
    region: dict,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Update an existing region in external database.
    """
    try:
        # Check if region exists
        check_query = text("SELECT region_id FROM regions WHERE region_id = :region_id")
        check_result = await db.execute(check_query, {"region_id": region_id})
        if not check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Region with ID {region_id} not found",
            )

        # Build UPDATE clause dynamically
        update_fields = []
        params = {"region_id": region_id}

        if "region_name" in region and region["region_name"] is not None:
            update_fields.append("region_name = :region_name")
            params["region_name"] = region["region_name"]

        if "region_code" in region and region["region_code"] is not None:
            update_fields.append("region_code = :region_code")
            params["region_code"] = region["region_code"]

        # Add updated_by
        update_fields.append("updated_by = :updated_by")
        params["updated_by"] = region.get("updated_by", "api")

        if not update_fields:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="No fields to update",
            )

        update_query = text(f"""
            UPDATE regions
            SET {', '.join(update_fields)}
            WHERE region_id = :region_id
            RETURNING region_id, region_name, region_code,
                      created_at, created_by, updated_at, updated_by
        """)

        result = await db.execute(update_query, params)
        await db.commit()

        row = result.fetchone()
        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error updating region: {str(e)}",
        )


@router.delete("/{region_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_region(
    region_id: int,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Delete a region from external database.
    """
    try:
        # Check if region exists
        check_query = text("SELECT region_id FROM regions WHERE region_id = :region_id")
        check_result = await db.execute(check_query, {"region_id": region_id})
        if not check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Region with ID {region_id} not found",
            )

        delete_query = text("DELETE FROM regions WHERE region_id = :region_id")
        await db.execute(delete_query, {"region_id": region_id})
        await db.commit()

        return None

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error deleting region: {str(e)}",
        )
