"""
Qualifications router - Full CRUD for qualifications table with pagination
Connects to EXTERNAL database (data tables)
"""
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text
from typing import List, Optional
import math

from database import get_external_db
from models import PaginatedResponse


router = APIRouter(prefix="/qualifications", tags=["Qualifications"])


@router.get("/", response_model=PaginatedResponse)
async def list_qualifications(
    page: int = Query(1, ge=1, description="Page number"),
    per_page: int = Query(50, ge=1, le=200, description="Items per page"),
    category: Optional[str] = Query(None, description="Filter by qualification category"),
    certification_required: Optional[bool] = Query(None, description="Filter by certification requirement"),
    qualification_name: Optional[str] = Query(None, description="Search by qualification name (partial match)"),
    db: AsyncSession = Depends(get_external_db),
):
    """
    List all qualifications with pagination and optional filters
    """
    try:
        offset = (page - 1) * per_page

        # Build WHERE clause dynamically
        where_clauses = []
        params = {"limit": per_page, "offset": offset}

        if category:
            where_clauses.append("qualification_category = :category")
            params["category"] = category

        if certification_required is not None:
            where_clauses.append("certification_required = :certification_required")
            params["certification_required"] = certification_required

        if qualification_name:
            where_clauses.append("qualification_name ILIKE :qualification_name")
            params["qualification_name"] = f"%{qualification_name}%"

        where_sql = f"WHERE {' AND '.join(where_clauses)}" if where_clauses else ""

        # Count total
        count_query = text(f"SELECT COUNT(*) as total FROM qualifications {where_sql}")
        count_result = await db.execute(count_query, params)
        total = count_result.scalar()

        # Fetch qualifications
        query = text(f"""
            SELECT
                qualification_id, qualification_name, qualification_category,
                description, certification_required, validity_months, created_at
            FROM qualifications
            {where_sql}
            ORDER BY qualification_name
            LIMIT :limit OFFSET :offset
        """)

        result = await db.execute(query, params)
        rows = result.fetchall()

        qualifications = [dict(row._mapping) for row in rows]

        total_pages = math.ceil(total / per_page) if total > 0 else 0

        return PaginatedResponse(
            total=total,
            page=page,
            per_page=per_page,
            total_pages=total_pages,
            data=qualifications,
        )

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching qualifications: {str(e)}",
        )


@router.get("/{qualification_id}", response_model=Qualification)
async def get_qualification(
    qualification_id: int,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Get a single qualification by ID
    """
    try:
        query = text("""
            SELECT
                qualification_id, qualification_name, qualification_category,
                description, certification_required, validity_months, created_at
            FROM qualifications
            WHERE qualification_id = :qualification_id
        """)

        result = await db.execute(query, {"qualification_id": qualification_id})
        row = result.fetchone()

        if not row:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Qualification with ID {qualification_id} not found",
            )

        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching qualification: {str(e)}",
        )


@router.post("/", response_model=Qualification, status_code=status.HTTP_201_CREATED)
async def create_qualification(
    qualification: QualificationCreate,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Create a new qualification
    """
    try:
        # Check if qualification_name already exists
        check_query = text("SELECT qualification_id FROM qualifications WHERE qualification_name = :qualification_name")
        check_result = await db.execute(check_query, {"qualification_name": qualification.qualification_name})
        if check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Qualification with name {qualification.qualification_name} already exists",
            )

        insert_query = text("""
            INSERT INTO qualifications (
                qualification_name, qualification_category, description,
                certification_required, validity_months
            ) VALUES (
                :qualification_name, :qualification_category, :description,
                :certification_required, :validity_months
            )
            RETURNING
                qualification_id, qualification_name, qualification_category,
                description, certification_required, validity_months, created_at
        """)

        result = await db.execute(
            insert_query,
            {
                "qualification_name": qualification.qualification_name,
                "qualification_category": qualification.qualification_category,
                "description": qualification.description,
                "certification_required": qualification.certification_required,
                "validity_months": qualification.validity_months,
            },
        )

        await db.commit()
        row = result.fetchone()
        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating qualification: {str(e)}",
        )


@router.put("/{qualification_id}", response_model=Qualification)
async def update_qualification(
    qualification_id: int,
    qualification: QualificationUpdate,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Update an existing qualification
    """
    try:
        # Check if qualification exists
        check_query = text("SELECT qualification_id FROM qualifications WHERE qualification_id = :qualification_id")
        check_result = await db.execute(check_query, {"qualification_id": qualification_id})
        if not check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Qualification with ID {qualification_id} not found",
            )

        # Build UPDATE clause dynamically
        update_fields = []
        params = {"qualification_id": qualification_id}

        if qualification.qualification_name is not None:
            update_fields.append("qualification_name = :qualification_name")
            params["qualification_name"] = qualification.qualification_name

        if qualification.qualification_category is not None:
            update_fields.append("qualification_category = :qualification_category")
            params["qualification_category"] = qualification.qualification_category

        if qualification.description is not None:
            update_fields.append("description = :description")
            params["description"] = qualification.description

        if qualification.certification_required is not None:
            update_fields.append("certification_required = :certification_required")
            params["certification_required"] = qualification.certification_required

        if qualification.validity_months is not None:
            update_fields.append("validity_months = :validity_months")
            params["validity_months"] = qualification.validity_months

        if not update_fields:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="No fields to update",
            )

        update_query = text(f"""
            UPDATE qualifications
            SET {', '.join(update_fields)}
            WHERE qualification_id = :qualification_id
            RETURNING
                qualification_id, qualification_name, qualification_category,
                description, certification_required, validity_months, created_at
        """)

        result = await db.execute(update_query, params)
        await db.commit()

        row = result.fetchone()
        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error updating qualification: {str(e)}",
        )


@router.delete("/{qualification_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_qualification(
    qualification_id: int,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Delete a qualification
    """
    try:
        # Check if qualification exists
        check_query = text("SELECT qualification_id FROM qualifications WHERE qualification_id = :qualification_id")
        check_result = await db.execute(check_query, {"qualification_id": qualification_id})
        if not check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Qualification with ID {qualification_id} not found",
            )

        delete_query = text("DELETE FROM qualifications WHERE qualification_id = :qualification_id")
        await db.execute(delete_query, {"qualification_id": qualification_id})
        await db.commit()

        return None

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error deleting qualification: {str(e)}",
        )
