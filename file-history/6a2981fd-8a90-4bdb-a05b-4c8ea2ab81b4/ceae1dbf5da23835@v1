"""
Resources router - Full CRUD for resources table with pagination
"""
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text
from typing import List, Optional
from datetime import datetime
import math

from database import get_db
from models import (
    Resource,
    ResourceCreate,
    ResourceUpdate,
    PaginatedResponse,
    ResourceType,
    ResourceStatus,
)
from config import settings


router = APIRouter(prefix="/resources", tags=["Resources"])


@router.get("/", response_model=PaginatedResponse)
async def list_resources(
    page: int = Query(1, ge=1, description="Page number"),
    per_page: int = Query(50, ge=1, le=200, description="Items per page"),
    type: Optional[ResourceType] = Query(None, description="Filter by resource type"),
    status: Optional[ResourceStatus] = Query(None, description="Filter by status"),
    region_id: Optional[int] = Query(None, description="Filter by region ID"),
    team_id: Optional[int] = Query(None, description="Filter by team ID"),
    db: AsyncSession = Depends(get_db),
):
    """
    List all resources with pagination and optional filters
    """
    try:
        offset = (page - 1) * per_page

        # Build WHERE clause dynamically
        where_clauses = []
        params = {"limit": per_page, "offset": offset}

        if type:
            where_clauses.append("type = :type")
            params["type"] = type.value

        if status:
            where_clauses.append("status = :status")
            params["status"] = status.value

        if region_id:
            where_clauses.append("region_id = :region_id")
            params["region_id"] = region_id

        if team_id:
            where_clauses.append("team_id = :team_id")
            params["team_id"] = team_id

        where_sql = f"WHERE {' AND '.join(where_clauses)}" if where_clauses else ""

        # Count total
        count_query = text(f"SELECT COUNT(*) as total FROM resources {where_sql}")
        count_result = await db.execute(count_query, params)
        total = count_result.scalar()

        # Fetch resources
        query = text(f"""
            SELECT
                resource_id, type, first_name, last_name, email, phone,
                region_id, team_id, sub_group_id, home_location,
                contract, shift_pref, weekly_hours, cost_per_hour,
                qualifications, availability_pattern, hire_date, status,
                created_at, updated_at
            FROM resources
            {where_sql}
            ORDER BY created_at DESC
            LIMIT :limit OFFSET :offset
        """)

        result = await db.execute(query, params)
        rows = result.fetchall()

        resources = [dict(row._mapping) for row in rows]

        total_pages = math.ceil(total / per_page) if total > 0 else 0

        return PaginatedResponse(
            total=total,
            page=page,
            per_page=per_page,
            total_pages=total_pages,
            data=resources,
        )

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching resources: {str(e)}",
        )


@router.get("/{resource_id}", response_model=Resource)
async def get_resource(
    resource_id: str,
    db: AsyncSession = Depends(get_db),
):
    """
    Get a single resource by ID
    """
    try:
        query = text("""
            SELECT
                resource_id, type, first_name, last_name, email, phone,
                region_id, team_id, sub_group_id, home_location,
                contract, shift_pref, weekly_hours, cost_per_hour,
                qualifications, availability_pattern, hire_date, status,
                created_at, updated_at
            FROM resources
            WHERE resource_id = :resource_id
        """)

        result = await db.execute(query, {"resource_id": resource_id})
        row = result.fetchone()

        if not row:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Resource with ID {resource_id} not found",
            )

        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching resource: {str(e)}",
        )


@router.post("/", response_model=Resource, status_code=status.HTTP_201_CREATED)
async def create_resource(
    resource: ResourceCreate,
    db: AsyncSession = Depends(get_db),
):
    """
    Create a new resource
    """
    try:
        # Check if resource_id already exists
        check_query = text("SELECT resource_id FROM resources WHERE resource_id = :resource_id")
        check_result = await db.execute(check_query, {"resource_id": resource.resource_id})
        if check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Resource with ID {resource.resource_id} already exists",
            )

        # Convert qualifications list to JSON array string
        qualifications_json = None
        if resource.qualifications:
            import json
            qualifications_json = json.dumps(resource.qualifications)

        # Convert availability_pattern dict to JSON string
        availability_json = None
        if resource.availability_pattern:
            import json
            availability_json = json.dumps(resource.availability_pattern)

        insert_query = text("""
            INSERT INTO resources (
                resource_id, type, first_name, last_name, email, phone,
                region_id, team_id, sub_group_id, home_location,
                contract, shift_pref, weekly_hours, cost_per_hour,
                qualifications, availability_pattern, hire_date, status
            ) VALUES (
                :resource_id, :type, :first_name, :last_name, :email, :phone,
                :region_id, :team_id, :sub_group_id, :home_location,
                :contract, :shift_pref, :weekly_hours, :cost_per_hour,
                :qualifications::jsonb, :availability_pattern::jsonb, :hire_date, :status
            )
            RETURNING
                resource_id, type, first_name, last_name, email, phone,
                region_id, team_id, sub_group_id, home_location,
                contract, shift_pref, weekly_hours, cost_per_hour,
                qualifications, availability_pattern, hire_date, status,
                created_at, updated_at
        """)

        result = await db.execute(
            insert_query,
            {
                "resource_id": resource.resource_id,
                "type": resource.type.value,
                "first_name": resource.first_name,
                "last_name": resource.last_name,
                "email": resource.email,
                "phone": resource.phone,
                "region_id": resource.region_id,
                "team_id": resource.team_id,
                "sub_group_id": resource.sub_group_id,
                "home_location": resource.home_location,
                "contract": resource.contract.value if resource.contract else None,
                "shift_pref": resource.shift_pref.value if resource.shift_pref else None,
                "weekly_hours": resource.weekly_hours,
                "cost_per_hour": resource.cost_per_hour,
                "qualifications": qualifications_json,
                "availability_pattern": availability_json,
                "hire_date": resource.hire_date,
                "status": resource.status.value if resource.status else ResourceStatus.ACTIF.value,
            },
        )

        await db.commit()
        row = result.fetchone()
        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating resource: {str(e)}",
        )


@router.put("/{resource_id}", response_model=Resource)
async def update_resource(
    resource_id: str,
    resource: ResourceUpdate,
    db: AsyncSession = Depends(get_db),
):
    """
    Update an existing resource
    """
    try:
        # Check if resource exists
        check_query = text("SELECT resource_id FROM resources WHERE resource_id = :resource_id")
        check_result = await db.execute(check_query, {"resource_id": resource_id})
        if not check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Resource with ID {resource_id} not found",
            )

        # Build UPDATE clause dynamically based on provided fields
        update_fields = []
        params = {"resource_id": resource_id}

        if resource.type is not None:
            update_fields.append("type = :type")
            params["type"] = resource.type.value

        if resource.first_name is not None:
            update_fields.append("first_name = :first_name")
            params["first_name"] = resource.first_name

        if resource.last_name is not None:
            update_fields.append("last_name = :last_name")
            params["last_name"] = resource.last_name

        if resource.email is not None:
            update_fields.append("email = :email")
            params["email"] = resource.email

        if resource.phone is not None:
            update_fields.append("phone = :phone")
            params["phone"] = resource.phone

        if resource.region_id is not None:
            update_fields.append("region_id = :region_id")
            params["region_id"] = resource.region_id

        if resource.team_id is not None:
            update_fields.append("team_id = :team_id")
            params["team_id"] = resource.team_id

        if resource.sub_group_id is not None:
            update_fields.append("sub_group_id = :sub_group_id")
            params["sub_group_id"] = resource.sub_group_id

        if resource.home_location is not None:
            update_fields.append("home_location = :home_location")
            params["home_location"] = resource.home_location

        if resource.contract is not None:
            update_fields.append("contract = :contract")
            params["contract"] = resource.contract.value

        if resource.shift_pref is not None:
            update_fields.append("shift_pref = :shift_pref")
            params["shift_pref"] = resource.shift_pref.value

        if resource.weekly_hours is not None:
            update_fields.append("weekly_hours = :weekly_hours")
            params["weekly_hours"] = resource.weekly_hours

        if resource.cost_per_hour is not None:
            update_fields.append("cost_per_hour = :cost_per_hour")
            params["cost_per_hour"] = resource.cost_per_hour

        if resource.qualifications is not None:
            import json
            update_fields.append("qualifications = :qualifications::jsonb")
            params["qualifications"] = json.dumps(resource.qualifications)

        if resource.availability_pattern is not None:
            import json
            update_fields.append("availability_pattern = :availability_pattern::jsonb")
            params["availability_pattern"] = json.dumps(resource.availability_pattern)

        if resource.hire_date is not None:
            update_fields.append("hire_date = :hire_date")
            params["hire_date"] = resource.hire_date

        if resource.status is not None:
            update_fields.append("status = :status")
            params["status"] = resource.status.value

        if not update_fields:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="No fields to update",
            )

        update_query = text(f"""
            UPDATE resources
            SET {', '.join(update_fields)}
            WHERE resource_id = :resource_id
            RETURNING
                resource_id, type, first_name, last_name, email, phone,
                region_id, team_id, sub_group_id, home_location,
                contract, shift_pref, weekly_hours, cost_per_hour,
                qualifications, availability_pattern, hire_date, status,
                created_at, updated_at
        """)

        result = await db.execute(update_query, params)
        await db.commit()

        row = result.fetchone()
        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error updating resource: {str(e)}",
        )


@router.delete("/{resource_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_resource(
    resource_id: str,
    db: AsyncSession = Depends(get_db),
):
    """
    Delete a resource
    """
    try:
        # Check if resource exists
        check_query = text("SELECT resource_id FROM resources WHERE resource_id = :resource_id")
        check_result = await db.execute(check_query, {"resource_id": resource_id})
        if not check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Resource with ID {resource_id} not found",
            )

        delete_query = text("DELETE FROM resources WHERE resource_id = :resource_id")
        await db.execute(delete_query, {"resource_id": resource_id})
        await db.commit()

        return None

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error deleting resource: {str(e)}",
        )
