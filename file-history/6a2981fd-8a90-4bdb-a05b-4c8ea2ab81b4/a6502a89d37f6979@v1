"""
Locations router - Full CRUD for locations table with pagination
"""
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text
from typing import List, Optional
import math

from database import get_db
from models import (
    Location,
    LocationCreate,
    LocationUpdate,
    PaginatedResponse,
)


router = APIRouter(prefix="/locations", tags=["Locations"])


@router.get("/", response_model=PaginatedResponse)
async def list_locations(
    page: int = Query(1, ge=1, description="Page number"),
    per_page: int = Query(50, ge=1, le=200, description="Items per page"),
    canton: Optional[str] = Query(None, description="Filter by canton"),
    location_name: Optional[str] = Query(None, description="Search by location name (partial match)"),
    db: AsyncSession = Depends(get_db),
):
    """
    List all locations with pagination and optional filters
    """
    try:
        offset = (page - 1) * per_page

        # Build WHERE clause dynamically
        where_clauses = []
        params = {"limit": per_page, "offset": offset}

        if canton:
            where_clauses.append("canton = :canton")
            params["canton"] = canton

        if location_name:
            where_clauses.append("location_name ILIKE :location_name")
            params["location_name"] = f"%{location_name}%"

        where_sql = f"WHERE {' AND '.join(where_clauses)}" if where_clauses else ""

        # Count total
        count_query = text(f"SELECT COUNT(*) as total FROM locations {where_sql}")
        count_result = await db.execute(count_query, params)
        total = count_result.scalar()

        # Fetch locations
        query = text(f"""
            SELECT
                location_id, location_name, location_code, canton,
                latitude, longitude, created_at
            FROM locations
            {where_sql}
            ORDER BY location_name
            LIMIT :limit OFFSET :offset
        """)

        result = await db.execute(query, params)
        rows = result.fetchall()

        locations = [dict(row._mapping) for row in rows]

        total_pages = math.ceil(total / per_page) if total > 0 else 0

        return PaginatedResponse(
            total=total,
            page=page,
            per_page=per_page,
            total_pages=total_pages,
            data=locations,
        )

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching locations: {str(e)}",
        )


@router.get("/{location_id}", response_model=Location)
async def get_location(
    location_id: int,
    db: AsyncSession = Depends(get_db),
):
    """
    Get a single location by ID
    """
    try:
        query = text("""
            SELECT
                location_id, location_name, location_code, canton,
                latitude, longitude, created_at
            FROM locations
            WHERE location_id = :location_id
        """)

        result = await db.execute(query, {"location_id": location_id})
        row = result.fetchone()

        if not row:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Location with ID {location_id} not found",
            )

        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching location: {str(e)}",
        )


@router.post("/", response_model=Location, status_code=status.HTTP_201_CREATED)
async def create_location(
    location: LocationCreate,
    db: AsyncSession = Depends(get_db),
):
    """
    Create a new location
    """
    try:
        # Check if location_name already exists
        check_query = text("SELECT location_id FROM locations WHERE location_name = :location_name")
        check_result = await db.execute(check_query, {"location_name": location.location_name})
        if check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Location with name {location.location_name} already exists",
            )

        insert_query = text("""
            INSERT INTO locations (location_name, location_code, canton, latitude, longitude)
            VALUES (:location_name, :location_code, :canton, :latitude, :longitude)
            RETURNING location_id, location_name, location_code, canton, latitude, longitude, created_at
        """)

        result = await db.execute(
            insert_query,
            {
                "location_name": location.location_name,
                "location_code": location.location_code,
                "canton": location.canton,
                "latitude": location.latitude,
                "longitude": location.longitude,
            },
        )

        await db.commit()
        row = result.fetchone()
        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating location: {str(e)}",
        )


@router.put("/{location_id}", response_model=Location)
async def update_location(
    location_id: int,
    location: LocationUpdate,
    db: AsyncSession = Depends(get_db),
):
    """
    Update an existing location
    """
    try:
        # Check if location exists
        check_query = text("SELECT location_id FROM locations WHERE location_id = :location_id")
        check_result = await db.execute(check_query, {"location_id": location_id})
        if not check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Location with ID {location_id} not found",
            )

        # Build UPDATE clause dynamically
        update_fields = []
        params = {"location_id": location_id}

        if location.location_name is not None:
            update_fields.append("location_name = :location_name")
            params["location_name"] = location.location_name

        if location.location_code is not None:
            update_fields.append("location_code = :location_code")
            params["location_code"] = location.location_code

        if location.canton is not None:
            update_fields.append("canton = :canton")
            params["canton"] = location.canton

        if location.latitude is not None:
            update_fields.append("latitude = :latitude")
            params["latitude"] = location.latitude

        if location.longitude is not None:
            update_fields.append("longitude = :longitude")
            params["longitude"] = location.longitude

        if not update_fields:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="No fields to update",
            )

        update_query = text(f"""
            UPDATE locations
            SET {', '.join(update_fields)}
            WHERE location_id = :location_id
            RETURNING location_id, location_name, location_code, canton, latitude, longitude, created_at
        """)

        result = await db.execute(update_query, params)
        await db.commit()

        row = result.fetchone()
        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error updating location: {str(e)}",
        )


@router.delete("/{location_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_location(
    location_id: int,
    db: AsyncSession = Depends(get_db),
):
    """
    Delete a location
    """
    try:
        # Check if location exists
        check_query = text("SELECT location_id FROM locations WHERE location_id = :location_id")
        check_result = await db.execute(check_query, {"location_id": location_id})
        if not check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Location with ID {location_id} not found",
            )

        delete_query = text("DELETE FROM locations WHERE location_id = :location_id")
        await db.execute(delete_query, {"location_id": location_id})
        await db.commit()

        return None

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error deleting location: {str(e)}",
        )
