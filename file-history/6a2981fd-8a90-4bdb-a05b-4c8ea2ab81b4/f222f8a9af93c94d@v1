"""
Absences router - Full CRUD for absences table with pagination
"""
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text
from typing import List, Optional
from datetime import date
import math

from database import get_db
from models import (
    Absence,
    AbsenceCreate,
    AbsenceUpdate,
    PaginatedResponse,
    AbsenceType,
    AbsenceStatus,
)


router = APIRouter(prefix="/absences", tags=["Absences"])


@router.get("/", response_model=PaginatedResponse)
async def list_absences(
    page: int = Query(1, ge=1, description="Page number"),
    per_page: int = Query(50, ge=1, le=200, description="Items per page"),
    resource_id: Optional[str] = Query(None, description="Filter by resource ID"),
    type: Optional[AbsenceType] = Query(None, description="Filter by absence type"),
    status: Optional[AbsenceStatus] = Query(None, description="Filter by status"),
    start_date: Optional[date] = Query(None, description="Filter by start date (from)"),
    end_date: Optional[date] = Query(None, description="Filter by end date (to)"),
    db: AsyncSession = Depends(get_db),
):
    """
    List all absences with pagination and optional filters
    """
    try:
        offset = (page - 1) * per_page

        # Build WHERE clause dynamically
        where_clauses = []
        params = {"limit": per_page, "offset": offset}

        if resource_id:
            where_clauses.append("resource_id = :resource_id")
            params["resource_id"] = resource_id

        if type:
            where_clauses.append("type = :type")
            params["type"] = type.value

        if status:
            where_clauses.append("status = :status")
            params["status"] = status.value

        if start_date:
            where_clauses.append("start_date >= :start_date")
            params["start_date"] = start_date

        if end_date:
            where_clauses.append("end_date <= :end_date")
            params["end_date"] = end_date

        where_sql = f"WHERE {' AND '.join(where_clauses)}" if where_clauses else ""

        # Count total
        count_query = text(f"SELECT COUNT(*) as total FROM absences {where_sql}")
        count_result = await db.execute(count_query, params)
        total = count_result.scalar()

        # Fetch absences
        query = text(f"""
            SELECT
                absence_id, resource_id, type, start_date, end_date,
                number_of_days, status, notes, approved_by, created_date,
                created_at, updated_at
            FROM absences
            {where_sql}
            ORDER BY start_date DESC, created_at DESC
            LIMIT :limit OFFSET :offset
        """)

        result = await db.execute(query, params)
        rows = result.fetchall()

        absences = [dict(row._mapping) for row in rows]

        total_pages = math.ceil(total / per_page) if total > 0 else 0

        return PaginatedResponse(
            total=total,
            page=page,
            per_page=per_page,
            total_pages=total_pages,
            data=absences,
        )

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching absences: {str(e)}",
        )


@router.get("/{absence_id}", response_model=Absence)
async def get_absence(
    absence_id: str,
    db: AsyncSession = Depends(get_db),
):
    """
    Get a single absence by ID
    """
    try:
        query = text("""
            SELECT
                absence_id, resource_id, type, start_date, end_date,
                number_of_days, status, notes, approved_by, created_date,
                created_at, updated_at
            FROM absences
            WHERE absence_id = :absence_id
        """)

        result = await db.execute(query, {"absence_id": absence_id})
        row = result.fetchone()

        if not row:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Absence with ID {absence_id} not found",
            )

        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching absence: {str(e)}",
        )


@router.post("/", response_model=Absence, status_code=status.HTTP_201_CREATED)
async def create_absence(
    absence: AbsenceCreate,
    db: AsyncSession = Depends(get_db),
):
    """
    Create a new absence
    """
    try:
        # Check if absence_id already exists
        check_query = text("SELECT absence_id FROM absences WHERE absence_id = :absence_id")
        check_result = await db.execute(check_query, {"absence_id": absence.absence_id})
        if check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Absence with ID {absence.absence_id} already exists",
            )

        # Verify resource exists
        resource_check = text("SELECT resource_id FROM resources WHERE resource_id = :resource_id")
        resource_result = await db.execute(resource_check, {"resource_id": absence.resource_id})
        if not resource_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Resource with ID {absence.resource_id} not found",
            )

        # Validate dates
        if absence.end_date < absence.start_date:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="End date must be greater than or equal to start date",
            )

        insert_query = text("""
            INSERT INTO absences (
                absence_id, resource_id, type, start_date, end_date,
                status, notes, approved_by, created_date
            ) VALUES (
                :absence_id, :resource_id, :type, :start_date, :end_date,
                :status, :notes, :approved_by, :created_date
            )
            RETURNING
                absence_id, resource_id, type, start_date, end_date,
                number_of_days, status, notes, approved_by, created_date,
                created_at, updated_at
        """)

        result = await db.execute(
            insert_query,
            {
                "absence_id": absence.absence_id,
                "resource_id": absence.resource_id,
                "type": absence.type.value,
                "start_date": absence.start_date,
                "end_date": absence.end_date,
                "status": absence.status.value if absence.status else AbsenceStatus.EN_ATTENTE.value,
                "notes": absence.notes,
                "approved_by": absence.approved_by,
                "created_date": absence.created_date,
            },
        )

        await db.commit()
        row = result.fetchone()
        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating absence: {str(e)}",
        )


@router.put("/{absence_id}", response_model=Absence)
async def update_absence(
    absence_id: str,
    absence: AbsenceUpdate,
    db: AsyncSession = Depends(get_db),
):
    """
    Update an existing absence
    """
    try:
        # Check if absence exists
        check_query = text("SELECT absence_id FROM absences WHERE absence_id = :absence_id")
        check_result = await db.execute(check_query, {"absence_id": absence_id})
        if not check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Absence with ID {absence_id} not found",
            )

        # Build UPDATE clause dynamically
        update_fields = []
        params = {"absence_id": absence_id}

        if absence.resource_id is not None:
            # Verify resource exists
            resource_check = text("SELECT resource_id FROM resources WHERE resource_id = :resource_id")
            resource_result = await db.execute(resource_check, {"resource_id": absence.resource_id})
            if not resource_result.fetchone():
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Resource with ID {absence.resource_id} not found",
                )
            update_fields.append("resource_id = :resource_id")
            params["resource_id"] = absence.resource_id

        if absence.type is not None:
            update_fields.append("type = :type")
            params["type"] = absence.type.value

        if absence.start_date is not None:
            update_fields.append("start_date = :start_date")
            params["start_date"] = absence.start_date

        if absence.end_date is not None:
            update_fields.append("end_date = :end_date")
            params["end_date"] = absence.end_date

        if absence.status is not None:
            update_fields.append("status = :status")
            params["status"] = absence.status.value

        if absence.notes is not None:
            update_fields.append("notes = :notes")
            params["notes"] = absence.notes

        if absence.approved_by is not None:
            update_fields.append("approved_by = :approved_by")
            params["approved_by"] = absence.approved_by

        if absence.created_date is not None:
            update_fields.append("created_date = :created_date")
            params["created_date"] = absence.created_date

        if not update_fields:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="No fields to update",
            )

        update_query = text(f"""
            UPDATE absences
            SET {', '.join(update_fields)}
            WHERE absence_id = :absence_id
            RETURNING
                absence_id, resource_id, type, start_date, end_date,
                number_of_days, status, notes, approved_by, created_date,
                created_at, updated_at
        """)

        result = await db.execute(update_query, params)
        await db.commit()

        row = result.fetchone()
        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error updating absence: {str(e)}",
        )


@router.delete("/{absence_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_absence(
    absence_id: str,
    db: AsyncSession = Depends(get_db),
):
    """
    Delete an absence
    """
    try:
        # Check if absence exists
        check_query = text("SELECT absence_id FROM absences WHERE absence_id = :absence_id")
        check_result = await db.execute(check_query, {"absence_id": absence_id})
        if not check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Absence with ID {absence_id} not found",
            )

        delete_query = text("DELETE FROM absences WHERE absence_id = :absence_id")
        await db.execute(delete_query, {"absence_id": absence_id})
        await db.commit()

        return None

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error deleting absence: {str(e)}",
        )
