"""
LC_02: Maximum Daily Hours in 14-Hour Span Analyzer
Analyzes violations of 14h span limits (legal 9h, company 8.5h)
"""
from .base_analyzer import ConstraintAnalyzer
import sys
sys.path.append('../..')
from config import SCALING_FACTOR


class LC_02_Analyzer(ConstraintAnalyzer):
    """Analyzer for LC_02 (maximum hours in 14h span)"""

    def __init__(self):
        super().__init__(
            constraint_id='LC_02',
            constraint_name='max_hours_in_14h'
        )

    def analyze_violations(self, solution, data, constraints, violation_metadata):
        """
        Analyze 14h span violations

        Returns detailed breakdown of violations by resource and window
        """
        # Filter metadata for this constraint
        my_violations = [
            v for v in violation_metadata
            if v['constraint_id'] == 'LC_02'
        ]

        if not my_violations:
            return {
                "constraint_id": "LC_02",
                "constraint_name": "max_hours_in_14h",
                "total_violations": 0,
                "total_violation_amount": 0.0,
                "affected_resources": 0,
                "severity_breakdown": {"LOW": 0, "MEDIUM": 0, "HIGH": 0},
                "detailed_violations": [],
                "message": "No violations detected"
            }

        # Group by resource
        violations_by_resource = {}
        total_violation_amount = 0.0

        for viol_meta in my_violations:
            resource_id = viol_meta['resource_id']
            window_idx = viol_meta['window_idx']
            window = viol_meta['window']

            # Calculate actual hours for this resource in this window
            actual_hours = self._calculate_actual_hours(
                solution, data, resource_id, window_idx
            )

            # Only process if there's an actual violation
            company_limit = viol_meta['company_limit']
            if actual_hours <= company_limit:
                continue  # No violation

            violation_amount = actual_hours - company_limit
            total_violation_amount += violation_amount

            if resource_id not in violations_by_resource:
                violations_by_resource[resource_id] = []

            severity = self.classify_severity(
                violation_amount,
                viol_meta['legal_limit'],
                viol_meta['company_limit']
            )

            violations_by_resource[resource_id].append({
                'context': {
                    'window': window,
                    'window_idx': window_idx
                },
                'legal_limit': viol_meta['legal_limit'],
                'company_limit': viol_meta['company_limit'],
                'actual_value': actual_hours,
                'violation_amount': violation_amount,
                'severity': severity,
                'affected_assignments': viol_meta['assignments_in_window'],
                'how_to_fix': self._generate_fix_suggestions(
                    viol_meta, actual_hours, violation_amount, data
                )
            })

        # Build severity breakdown
        severity_breakdown = {"LOW": 0, "MEDIUM": 0, "HIGH": 0}
        for resource_viols in violations_by_resource.values():
            for v in resource_viols:
                severity_breakdown[v['severity']] += 1

        # Format detailed violations
        detailed_violations = [
            {
                'resource_id': resource_id,
                'total_violations': len(viols),
                'total_violation_amount': sum(v['violation_amount'] for v in viols),
                'violations': viols
            }
            for resource_id, viols in violations_by_resource.items()
        ]

        return {
            "constraint_id": "LC_02",
            "constraint_name": "max_hours_in_14h",
            "total_violations": sum(len(v) for v in violations_by_resource.values()),
            "total_violation_amount": round(total_violation_amount, 2),
            "affected_resources": len(violations_by_resource),
            "severity_breakdown": severity_breakdown,
            "detailed_violations": detailed_violations
        }

    def check_would_violate(self, simulated_assignment, existing_assignments,
                           data, constraints):
        """
        Check if adding this assignment would violate 14h span limits
        """
        MAX_HOURS_LEGAL = constraints.get_legal_value('max_hours_in_14h')
        MAX_HOURS_COMPANY = constraints.get_company_value('max_hours_in_14h')

        from datetime import datetime, timedelta

        sim_start = datetime.fromisoformat(simulated_assignment['start'])
        sim_end = datetime.fromisoformat(simulated_assignment['end'])
        sim_duration = simulated_assignment['duration_hours']

        # Check all possible 14h windows that overlap with this assignment
        violations = []

        # For each possible 14h window that overlaps the assignment
        for window_idx, window in enumerate(data.windows_14h):
            window_start = window['start']
            window_end = window['end']

            # Check if assignment overlaps this window
            if not (sim_end <= window_start or sim_start >= window_end):
                # Calculate hours in this window
                overlap_start = max(sim_start, window_start)
                overlap_end = min(sim_end, window_end)
                overlap_duration = (overlap_end - overlap_start).total_seconds() / 3600

                total_hours = overlap_duration

                # Add existing assignments in this window
                for existing in existing_assignments:
                    exist_start = datetime.fromisoformat(existing['start'])
                    exist_end = datetime.fromisoformat(existing['end'])

                    # Check if existing assignment overlaps this window
                    if not (exist_end <= window_start or exist_start >= window_end):
                        exist_overlap_start = max(exist_start, window_start)
                        exist_overlap_end = min(exist_end, window_end)
                        exist_overlap = (exist_overlap_end - exist_overlap_start).total_seconds() / 3600
                        total_hours += exist_overlap

                # Check against limits
                if total_hours > MAX_HOURS_LEGAL:
                    return {
                        "would_violate": True,
                        "violation_type": "legal",
                        "violation_amount": total_hours - MAX_HOURS_LEGAL,
                        "reason": f"Would exceed legal 14h limit: {total_hours:.1f}h > {MAX_HOURS_LEGAL}h",
                        "details": {
                            "window_idx": window_idx,
                            "window": str(window),
                            "total_hours": total_hours,
                            "legal_limit": MAX_HOURS_LEGAL
                        }
                    }
                elif total_hours > MAX_HOURS_COMPANY:
                    violations.append({
                        "would_violate": True,
                        "violation_type": "company",
                        "violation_amount": total_hours - MAX_HOURS_COMPANY,
                        "reason": f"Would exceed company 14h limit: {total_hours:.1f}h > {MAX_HOURS_COMPANY}h",
                        "details": {
                            "window_idx": window_idx,
                            "window": str(window),
                            "total_hours": total_hours,
                            "company_limit": MAX_HOURS_COMPANY
                        }
                    })

        # Return worst violation if any
        if violations:
            return violations[0]  # Return first company violation

        return {
            "would_violate": False,
            "violation_type": "none",
            "violation_amount": 0,
            "reason": "Within 14h span limits"
        }

    def suggest_weight_adjustment(self, violations):
        """Suggest weight adjustments based on 14h span violations"""
        total_viols = violations.get('total_violations', 0)
        total_amount = violations.get('total_violation_amount', 0)

        if total_viols == 0:
            return {
                "constraint_id": "LC_02",
                "current_weight": 1000,
                "suggested_adjustments": []
            }

        suggestions = []

        if total_viols > 50:
            suggestions.append({
                "new_weight": 1500,
                "expected_impact": "Stronger enforcement of 14h span limit",
                "trade_offs": "May reduce coverage by 2-4% as scheduling becomes more constrained"
            })

        if total_amount > 100:
            suggestions.append({
                "new_weight": 2000,
                "expected_impact": "Very strong enforcement - minimize daily overwork",
                "trade_offs": "Could significantly reduce coverage, may need shift restructuring"
            })

        if total_viols < 25 and total_amount < 50:
            suggestions.append({
                "new_weight": 700,
                "expected_impact": "More flexibility with 14h span limits",
                "trade_offs": "May increase coverage by 1-2% but increases daily fatigue risk"
            })

        return {
            "constraint_id": "LC_02",
            "current_weight": 1000,
            "suggested_adjustments": suggestions
        }

    def _calculate_actual_hours(self, solution, data, resource_id, window_idx):
        """Calculate actual hours worked in a 14h window"""
        # Get assignments - handle both attribute names for compatibility
        assignments = getattr(solution, 'solution_assignments', getattr(solution, 'assignments', []))

        total_hours = 0.0
        for assignment in assignments:
            if assignment['resource_id'] == resource_id:
                req_id = assignment['request_id']
                hours_in_window = data.get_task_hours_in_window(req_id, window_idx)
                total_hours += hours_in_window
        return total_hours

    def _generate_fix_suggestions(self, viol_meta, actual_hours, violation_amount, data):
        """Generate specific fix suggestions"""
        suggestions = []
        resource_id = viol_meta['resource_id']
        window = viol_meta['window']
        assignments = viol_meta['assignments_in_window']

        # Suggestion 1: Remove/reassign assignments
        if assignments:
            suggestions.append(
                f"Remove or split assignment {assignments[0]} to reduce hours in window {window}"
            )

        # Suggestion 2: Shift timing
        suggestions.append(
            f"Shift some assignments outside the 14h window {window}"
        )

        # Suggestion 3: Accept violation if minor
        if violation_amount < 1.0:
            suggestions.append(
                f"Accept violation ({violation_amount:.1f}h over) - within operational tolerance"
            )

        return suggestions
