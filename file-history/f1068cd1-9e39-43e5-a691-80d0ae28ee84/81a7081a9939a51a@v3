"""
Teams router - Full CRUD for teams table
Connects to EXTERNAL database (data tables)
"""
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text
from typing import List, Optional

from database import get_external_db


router = APIRouter(prefix="/teams", tags=["Teams"])


@router.get("/")
async def list_teams(
    region_id: Optional[int] = Query(None, description="Filter by region ID"),
    db: AsyncSession = Depends(get_external_db),
):
    """
    List all teams with optional region filter.
    Data comes from external database.
    """
    try:
        where_clause = "WHERE region_id = :region_id" if region_id else ""
        params = {"region_id": region_id} if region_id else {}

        query = text(f"""
            SELECT team_id, team_name, region_id, team_code,
                   created_at, created_by, updated_at, updated_by
            FROM teams
            {where_clause}
            ORDER BY team_name
        """)

        result = await db.execute(query, params)
        rows = result.fetchall()

        return [dict(row._mapping) for row in rows]

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching teams: {str(e)}",
        )


@router.get("/{team_id}")
async def get_team(
    team_id: int,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Get a single team by ID.
    Data comes from external database.
    """
    try:
        query = text("""
            SELECT team_id, team_name, region_id, team_code,
                   created_at, created_by, updated_at, updated_by
            FROM teams
            WHERE team_id = :team_id
        """)

        result = await db.execute(query, {"team_id": team_id})
        row = result.fetchone()

        if not row:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Team with ID {team_id} not found",
            )

        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching team: {str(e)}",
        )


@router.post("/", status_code=status.HTTP_201_CREATED)
async def create_team(
    team: dict,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Create a new team in external database.
    Required fields: team_name
    """
    try:
        # Validate required fields
        if "team_name" not in team or not team["team_name"]:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Missing required field: team_name",
            )

        # Check if team_name already exists
        check_query = text("SELECT team_id FROM teams WHERE team_name = :team_name")
        check_result = await db.execute(check_query, {"team_name": team["team_name"]})
        if check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Team with name {team['team_name']} already exists",
            )

        # Verify region exists if provided
        if team.get("region_id"):
            region_check = text("SELECT region_id FROM regions WHERE region_id = :region_id")
            region_result = await db.execute(region_check, {"region_id": team["region_id"]})
            if not region_result.fetchone():
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Region with ID {team['region_id']} not found",
                )

        insert_query = text("""
            INSERT INTO teams (team_name, region_id, team_code, created_by)
            VALUES (:team_name, :region_id, :team_code, :created_by)
            RETURNING team_id, team_name, region_id, team_code,
                      created_at, created_by, updated_at, updated_by
        """)

        result = await db.execute(
            insert_query,
            {
                "team_name": team.get("team_name"),
                "region_id": team.get("region_id"),
                "team_code": team.get("team_code"),
                "created_by": team.get("created_by", "api"),
            },
        )

        await db.commit()
        row = result.fetchone()
        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating team: {str(e)}",
        )


@router.put("/{team_id}")
async def update_team(
    team_id: int,
    team: dict,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Update an existing team in external database.
    """
    try:
        # Check if team exists
        check_query = text("SELECT team_id FROM teams WHERE team_id = :team_id")
        check_result = await db.execute(check_query, {"team_id": team_id})
        if not check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Team with ID {team_id} not found",
            )

        # Build UPDATE clause dynamically
        update_fields = []
        params = {"team_id": team_id}

        if "team_name" in team and team["team_name"] is not None:
            update_fields.append("team_name = :team_name")
            params["team_name"] = team["team_name"]

        if "region_id" in team and team["region_id"] is not None:
            # Verify region exists
            region_check = text("SELECT region_id FROM regions WHERE region_id = :region_id")
            region_result = await db.execute(region_check, {"region_id": team["region_id"]})
            if not region_result.fetchone():
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Region with ID {team['region_id']} not found",
                )
            update_fields.append("region_id = :region_id")
            params["region_id"] = team["region_id"]

        if "team_code" in team and team["team_code"] is not None:
            update_fields.append("team_code = :team_code")
            params["team_code"] = team["team_code"]

        # Add updated_by
        update_fields.append("updated_by = :updated_by")
        params["updated_by"] = team.get("updated_by", "api")

        if not update_fields:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="No fields to update",
            )

        update_query = text(f"""
            UPDATE teams
            SET {', '.join(update_fields)}
            WHERE team_id = :team_id
            RETURNING team_id, team_name, region_id, team_code,
                      created_at, created_by, updated_at, updated_by
        """)

        result = await db.execute(update_query, params)
        await db.commit()

        row = result.fetchone()
        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error updating team: {str(e)}",
        )


@router.delete("/{team_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_team(
    team_id: int,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Delete a team from external database.
    """
    try:
        # Check if team exists
        check_query = text("SELECT team_id FROM teams WHERE team_id = :team_id")
        check_result = await db.execute(check_query, {"team_id": team_id})
        if not check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Team with ID {team_id} not found",
            )

        delete_query = text("DELETE FROM teams WHERE team_id = :team_id")
        await db.execute(delete_query, {"team_id": team_id})
        await db.commit()

        return None

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error deleting team: {str(e)}",
        )
