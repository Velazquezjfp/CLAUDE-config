"""
Divisions router - Full CRUD for divisions table
Connects to EXTERNAL database (data tables)
Note: New table in v2 - Division organizational level
"""
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text
from typing import List, Optional

from database import get_external_db


router = APIRouter(prefix="/divisions", tags=["Divisions"])


@router.get("/")
async def list_divisions(
    db: AsyncSession = Depends(get_external_db),
):
    """
    List all divisions.
    Data comes from external database.
    """
    try:
        query = text("""
            SELECT division_id, division_name, division_code,
                   created_at, created_by, updated_at, updated_by
            FROM divisions
            ORDER BY division_name
        """)

        result = await db.execute(query)
        rows = result.fetchall()

        return [dict(row._mapping) for row in rows]

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching divisions: {str(e)}",
        )


@router.get("/{division_id}")
async def get_division(
    division_id: int,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Get a single division by ID.
    Data comes from external database.
    """
    try:
        query = text("""
            SELECT division_id, division_name, division_code,
                   created_at, created_by, updated_at, updated_by
            FROM divisions
            WHERE division_id = :division_id
        """)

        result = await db.execute(query, {"division_id": division_id})
        row = result.fetchone()

        if not row:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Division with ID {division_id} not found",
            )

        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching division: {str(e)}",
        )


@router.post("/", status_code=status.HTTP_201_CREATED)
async def create_division(
    division: dict,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Create a new division in external database.
    Required fields: division_name
    """
    try:
        # Validate required fields
        if "division_name" not in division or not division["division_name"]:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Missing required field: division_name",
            )

        # Check if division_name already exists
        check_query = text("SELECT division_id FROM divisions WHERE division_name = :division_name")
        check_result = await db.execute(check_query, {"division_name": division["division_name"]})
        if check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Division with name {division['division_name']} already exists",
            )

        insert_query = text("""
            INSERT INTO divisions (division_name, division_code, created_by)
            VALUES (:division_name, :division_code, :created_by)
            RETURNING division_id, division_name, division_code,
                      created_at, created_by, updated_at, updated_by
        """)

        result = await db.execute(
            insert_query,
            {
                "division_name": division.get("division_name"),
                "division_code": division.get("division_code"),
                "created_by": division.get("created_by", "api"),
            },
        )

        await db.commit()
        row = result.fetchone()
        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating division: {str(e)}",
        )


@router.put("/{division_id}")
async def update_division(
    division_id: int,
    division: dict,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Update an existing division in external database.
    """
    try:
        # Check if division exists
        check_query = text("SELECT division_id FROM divisions WHERE division_id = :division_id")
        check_result = await db.execute(check_query, {"division_id": division_id})
        if not check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Division with ID {division_id} not found",
            )

        # Build UPDATE clause dynamically
        update_fields = []
        params = {"division_id": division_id}

        if "division_name" in division and division["division_name"] is not None:
            update_fields.append("division_name = :division_name")
            params["division_name"] = division["division_name"]

        if "division_code" in division and division["division_code"] is not None:
            update_fields.append("division_code = :division_code")
            params["division_code"] = division["division_code"]

        # Add updated_by
        update_fields.append("updated_by = :updated_by")
        params["updated_by"] = division.get("updated_by", "api")

        if not update_fields:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="No fields to update",
            )

        update_query = text(f"""
            UPDATE divisions
            SET {', '.join(update_fields)}
            WHERE division_id = :division_id
            RETURNING division_id, division_name, division_code,
                      created_at, created_by, updated_at, updated_by
        """)

        result = await db.execute(update_query, params)
        await db.commit()

        row = result.fetchone()
        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error updating division: {str(e)}",
        )


@router.delete("/{division_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_division(
    division_id: int,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Delete a division from external database.
    """
    try:
        # Check if division exists
        check_query = text("SELECT division_id FROM divisions WHERE division_id = :division_id")
        check_result = await db.execute(check_query, {"division_id": division_id})
        if not check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Division with ID {division_id} not found",
            )

        delete_query = text("DELETE FROM divisions WHERE division_id = :division_id")
        await db.execute(delete_query, {"division_id": division_id})
        await db.commit()

        return None

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error deleting division: {str(e)}",
        )
