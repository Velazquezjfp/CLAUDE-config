#!/usr/bin/env python3
"""
Verify location and distance matrix completeness.
Checks for missing distances, asymmetry, and invalid location references.
"""
import sqlite3
from pathlib import Path

def main():
    db_path = Path(__file__).parent / 'database' / 'cff_scheduler.db'
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    print("=" * 70)
    print("LOCATION & DISTANCE MATRIX VERIFICATION")
    print("=" * 70)

    # 1. Get all locations
    cursor.execute('SELECT id, name FROM locations ORDER BY name')
    locations = cursor.fetchall()
    location_names = [row[1] for row in locations]

    print(f"\nüìç Total locations: {len(location_names)}")
    print(f"   Locations: {', '.join(location_names)}")

    # 2. Get all defined distances
    cursor.execute('SELECT from_location, to_location, distance_km FROM location_distances')
    distances = {(row[0], row[1]): row[2] for row in cursor.fetchall()}

    expected_entries = len(location_names) * len(location_names)
    print(f"\nüìè Distance matrix:")
    print(f"   Total entries: {len(distances)}")
    print(f"   Expected entries: {expected_entries}")

    # 3. Check completeness
    missing = []
    for from_loc in location_names:
        for to_loc in location_names:
            if (from_loc, to_loc) not in distances:
                missing.append((from_loc, to_loc))

    if missing:
        print(f"\n‚ùå MISSING {len(missing)} DISTANCES:")
        for pair in missing[:15]:  # Show first 15
            print(f"   - {pair[0]} ‚Üí {pair[1]}")
        if len(missing) > 15:
            print(f"   ... and {len(missing) - 15} more")
    else:
        print("\n‚úÖ Distance matrix is COMPLETE (all location pairs have distances)")

    # 4. Check symmetry
    asymmetric = []
    for (from_loc, to_loc), dist in distances.items():
        if from_loc != to_loc:  # Skip self-distances
            reverse_dist = distances.get((to_loc, from_loc))
            if reverse_dist is None:
                asymmetric.append(f"{from_loc}‚Üí{to_loc} exists but {to_loc}‚Üí{from_loc} missing")
            elif abs(dist - reverse_dist) > 0.01:  # Allow tiny float differences
                asymmetric.append(f"{from_loc}‚Üí{to_loc}: {dist}km != {to_loc}‚Üí{from_loc}: {reverse_dist}km")

    if asymmetric:
        print(f"\n‚ùå ASYMMETRIC DISTANCES ({len(asymmetric)}):")
        for issue in asymmetric[:10]:
            print(f"   - {issue}")
        if len(asymmetric) > 10:
            print(f"   ... and {len(asymmetric) - 10} more")
    else:
        print("\n‚úÖ Distance matrix is SYMMETRIC (A‚ÜíB = B‚ÜíA for all pairs)")

    # 5. Check self-distances
    bad_self = []
    for loc in location_names:
        dist = distances.get((loc, loc), None)
        if dist is None:
            bad_self.append(f"{loc} ‚Üí {loc}: MISSING")
        elif dist != 0:
            bad_self.append(f"{loc} ‚Üí {loc}: {dist}km (should be 0)")

    if bad_self:
        print(f"\n‚ùå INCORRECT SELF-DISTANCES:")
        for issue in bad_self:
            print(f"   - {issue}")
    else:
        print("\n‚úÖ All self-distances are 0 km")

    # 6. Check for resources using invalid locations
    cursor.execute('SELECT DISTINCT home_location FROM resources')
    resource_locs = [row[0] for row in cursor.fetchall()]
    invalid_resource_locs = [loc for loc in resource_locs if loc not in location_names]

    # 7. Check for requests using invalid locations
    cursor.execute('SELECT DISTINCT location FROM requests')
    request_locs = [row[0] for row in cursor.fetchall()]
    invalid_request_locs = [loc for loc in request_locs if loc not in location_names]

    if invalid_resource_locs:
        print(f"\n‚ùå RESOURCES with invalid locations ({len(invalid_resource_locs)}):")
        for loc in invalid_resource_locs:
            cursor.execute('SELECT COUNT(*) FROM resources WHERE home_location = ?', (loc,))
            count = cursor.fetchone()[0]
            print(f"   - '{loc}' (used by {count} resources)")

    if invalid_request_locs:
        print(f"\n‚ùå REQUESTS with invalid locations ({len(invalid_request_locs)}):")
        for loc in invalid_request_locs:
            cursor.execute('SELECT COUNT(*) FROM requests WHERE location = ?', (loc,))
            count = cursor.fetchone()[0]
            print(f"   - '{loc}' (used by {count} requests)")

    if not invalid_resource_locs and not invalid_request_locs:
        print("\n‚úÖ All resources and requests use valid location names")

    # Summary
    print("\n" + "=" * 70)
    print("SUMMARY")
    print("=" * 70)

    issues = []
    if missing:
        issues.append(f"{len(missing)} missing distance entries")
    if asymmetric:
        issues.append(f"{len(asymmetric)} asymmetric distances")
    if bad_self:
        issues.append(f"{len(bad_self)} incorrect self-distances")
    if invalid_resource_locs:
        issues.append(f"{len(invalid_resource_locs)} invalid resource locations")
    if invalid_request_locs:
        issues.append(f"{len(invalid_request_locs)} invalid request locations")

    if issues:
        print(f"\n‚ö†Ô∏è  FOUND {len(issues)} ISSUE(S):")
        for i, issue in enumerate(issues, 1):
            print(f"   {i}. {issue}")
        print("\nüí° These issues may cause solver errors!")
        print("   Fix by updating the database with missing/correct values.")
    else:
        print("\nüéâ ALL CHECKS PASSED!")
        print("   Location and distance matrix data is complete and consistent.")

    conn.close()

if __name__ == '__main__':
    main()
