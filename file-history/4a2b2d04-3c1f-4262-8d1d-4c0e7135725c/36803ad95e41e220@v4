"""
Solver service for CFF Scheduler.
Integrates with existing solver.py to run optimization from database data.
"""
import sys
from pathlib import Path
from datetime import datetime, date, timedelta
from typing import Dict, Optional

# Add parent directory for imports
sys.path.append(str(Path(__file__).parent.parent))

from data_models import ProblemData, Resource, Request, Holiday, LegalConstraints
from solver import CFFScheduler
from kpi_calculator import KPICalculator
from database.db_manager import DatabaseManager


class SolverService:
    """Service to run solver using database data."""

    def __init__(self, db_manager: DatabaseManager):
        self.db = db_manager

    def load_problem_from_db(self) -> ProblemData:
        """Load all problem data from database and create ProblemData instance."""

        # Get resources
        resources_data = self.db.get_all_resources()
        resources = []
        for r in resources_data:
            # Convert holiday dates from strings
            holidays = []
            for h in r.get('holidays', []):
                start = datetime.strptime(h['start'], '%Y-%m-%d').date()
                end = datetime.strptime(h['end'], '%Y-%m-%d').date()
                holidays.append(Holiday(start=start, end=end))

            resource = Resource(
                id=r['id'],
                name=r['name'],
                team=r['team'],
                home_location=r['home_location'],
                qualifications=set(r.get('qualifications', [])),
                contract_type=r['contract_type'],
                weekly_hours=r['weekly_hours'],
                holidays=holidays,
                resource_type=r.get('resource_type', 'internal'),
                cost_per_hour=r.get('cost_per_hour', 30.0)
            )
            resources.append(resource)

        # Get requests
        requests_data = self.db.get_all_requests()
        requests = []
        for req in requests_data:
            # Convert string dates/times to proper objects
            start_date = datetime.strptime(req['start_date'], '%Y-%m-%d').date()
            start_time = datetime.strptime(req['start_time'], '%H:%M').time()

            request = Request(
                id=req['id'],
                location=req['location'],
                start_date=start_date,
                start_time=start_time,
                duration_hours=req['duration_hours'],
                required_qualifications=set(req.get('required_qualifications', [])),
                people_needed=req['people_needed'],
                description=req.get('description', '')
            )
            requests.append(request)

        # Get distance matrix
        distance_matrix = self.db.get_distance_matrix()

        # Get legal constraints
        constraints_data = self.db.get_legal_constraints()

        # Convert time strings to time objects
        night_shift_start = datetime.strptime(constraints_data['night_shift_start'], '%H:%M').time()
        night_shift_end = datetime.strptime(constraints_data['night_shift_end'], '%H:%M').time()

        legal_constraints = LegalConstraints(
            max_daily_hours=constraints_data['max_daily_hours'],
            max_weekly_hours=constraints_data['max_weekly_hours'],
            min_daily_rest_hours=constraints_data['min_daily_rest_hours'],
            min_weekly_rest_hours=constraints_data['min_weekly_rest_hours'],
            max_consecutive_workdays=constraints_data['max_consecutive_workdays'],
            mandatory_break_after_hours=constraints_data['mandatory_break_after_hours'],
            mandatory_break_duration_minutes=constraints_data['mandatory_break_duration_minutes'],
            travel_time_counts_as_work=bool(constraints_data['travel_time_counts_as_work']),
            night_shift_start=night_shift_start,
            night_shift_end=night_shift_end
        )

        # Calculate planning period from requests
        if requests:
            # Get earliest and latest dates from all requests
            request_dates = [req.start_date for req in requests]
            planning_start = min(request_dates)
            planning_end = max(request_dates) + timedelta(days=1)  # Include the last day
        else:
            # Default to current week if no requests
            today = date.today()
            planning_start = today
            planning_end = today + timedelta(days=7)

        # Create ProblemData
        problem_data = ProblemData(
            resources=resources,
            requests=requests,
            distance_matrix=distance_matrix,
            legal_constraints=legal_constraints,
            planning_start=planning_start,
            planning_end=planning_end
        )

        return problem_data

    def run_solver(self, plan_config: Dict) -> Dict:
        """
        Run the solver with given configuration.

        Args:
            plan_config: Dictionary with solver configuration
                - time_limit_seconds: int
                - objective_type: 'cost', 'travel', or 'both'
                - max_travel_minutes: Optional[int]
                - team_cohesion_min: Optional[float]

        Returns:
            Dictionary with results including assignments and KPIs
        """

        # Load problem data
        problem_data = self.load_problem_from_db()

        # Create scheduler
        scheduler = CFFScheduler(problem_data)

        # Build and solve
        time_limit = plan_config.get('time_limit_seconds', 300)
        solution_found = scheduler.build_and_solve(time_limit=time_limit)

        if solution_found:
            # Get solution
            solution = scheduler.get_solution()

            # Calculate KPIs
            kpi_calc = KPICalculator(problem_data)
            kpis = kpi_calc.calculate_kpis(solution)

            # Format assignments for database
            assignments = []
            for resource_id, request_ids in solution['assignments'].items():
                resource = problem_data.resource_by_id[resource_id]
                for request_id in request_ids:
                    request = problem_data.request_by_id[request_id]

                    # Calculate work hours
                    from helpers import calculate_total_work_time
                    work_hours = calculate_total_work_time(
                        resource,
                        request,
                        problem_data.distance_matrix,
                        problem_data.legal_constraints
                    )

                    assignments.append({
                        'resource_id': resource_id,
                        'request_id': request_id,
                        'total_work_hours': work_hours
                    })

            return {
                'status': 'completed',
                'feasible': True,
                'solve_time': solution['statistics']['solve_time'],
                'objective_value': solution['statistics']['objective_value'],
                'assignments': assignments,
                'kpis': kpis,
                'error_message': None
            }
        else:
            # No solution found
            return {
                'status': 'completed',
                'feasible': False,
                'solve_time': None,
                'objective_value': None,
                'assignments': [],
                'kpis': {},
                'error_message': 'No feasible solution found. Check resource constraints and request requirements.'
            }
