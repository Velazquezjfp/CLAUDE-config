"""
Output formatting and visualization for CFF scheduling solution.
"""
import json
from typing import Dict, List, Optional
from datetime import date
from collections import defaultdict
from data_models import ProblemData
from helpers import calculate_total_work_time, get_requests_on_date


class OutputFormatter:
    """Formats and exports scheduling solution."""

    def __init__(self, problem_data: ProblemData, solution: Optional[Dict] = None):
        self.data = problem_data
        self.solution = solution

    def generate_schedule_by_resource(self) -> Dict:
        """Generate schedule organized by resource (worker view)."""
        if not self.solution:
            return {}

        schedule = {}

        for resource in self.data.resources:
            resource_id = resource.id
            if resource_id not in self.solution['assignments']:
                schedule[resource_id] = {
                    'name': resource.name,
                    'team': resource.team,
                    'assignments': []
                }
                continue

            assigned_request_ids = self.solution['assignments'][resource_id]
            assignments = []

            for req_id in assigned_request_ids:
                request = self.data.request_by_id[req_id]

                # Calculate travel info
                work_time = calculate_total_work_time(
                    resource,
                    request,
                    self.data.distance_matrix,
                    self.data.legal_constraints
                )

                assignment = {
                    'request_id': request.id,
                    'date': str(request.start_date),
                    'start_time': str(request.start_time),
                    'duration_hours': request.duration_hours,
                    'location': request.location,
                    'description': request.description,
                    'total_work_hours': round(work_time, 2)
                }
                assignments.append(assignment)

            # Sort by date and time
            assignments.sort(key=lambda x: (x['date'], x['start_time']))

            schedule[resource_id] = {
                'name': resource.name,
                'team': resource.team,
                'home_location': resource.home_location,
                'assignments': assignments,
                'total_assignments': len(assignments)
            }

        return schedule

    def generate_schedule_by_request(self) -> Dict:
        """Generate schedule organized by request (job view)."""
        if not self.solution:
            return {}

        schedule = {}

        for request in self.data.requests:
            assigned_resources = []

            for resource_id, request_ids in self.solution['assignments'].items():
                if request.id in request_ids:
                    resource = self.data.resource_by_id[resource_id]
                    assigned_resources.append({
                        'id': resource.id,
                        'name': resource.name,
                        'team': resource.team,
                        'home_location': resource.home_location,
                        'qualifications': sorted(list(resource.qualifications))
                    })

            schedule[request.id] = {
                'location': request.location,
                'date': str(request.start_date),
                'start_time': str(request.start_time),
                'duration_hours': request.duration_hours,
                'description': request.description,
                'required_qualifications': sorted(list(request.required_qualifications)),
                'people_needed': request.people_needed,
                'assigned_resources': assigned_resources
            }

        return schedule

    def generate_daily_summary(self) -> Dict:
        """Generate summary of assignments by day."""
        if not self.solution:
            return {}

        planning_days = self.data.get_planning_days()
        daily_summary = {}

        for day in planning_days:
            day_str = str(day)
            requests_on_day = get_requests_on_date(self.data.requests, day)

            # Count assigned workers
            workers_on_day = set()
            for resource_id, request_ids in self.solution['assignments'].items():
                for req_id in request_ids:
                    request = self.data.request_by_id[req_id]
                    if request.start_date == day:
                        workers_on_day.add(resource_id)

            daily_summary[day_str] = {
                'total_requests': len(requests_on_day),
                'total_workers_assigned': len(workers_on_day),
                'requests': [r.id for r in requests_on_day]
            }

        return daily_summary

    def generate_team_utilization(self) -> Dict:
        """Calculate utilization statistics by team."""
        if not self.solution:
            return {}

        team_stats = defaultdict(lambda: {
            'total_workers': 0,
            'assigned_workers': 0,
            'total_assignments': 0,
            'total_work_hours': 0.0
        })

        # Count workers by team
        for resource in self.data.resources:
            team_stats[resource.team]['total_workers'] += 1

            if resource.id in self.solution['assignments']:
                team_stats[resource.team]['assigned_workers'] += 1
                request_ids = self.solution['assignments'][resource.id]
                team_stats[resource.team]['total_assignments'] += len(request_ids)

                # Calculate total work hours
                for req_id in request_ids:
                    request = self.data.request_by_id[req_id]
                    work_time = calculate_total_work_time(
                        resource,
                        request,
                        self.data.distance_matrix,
                        self.data.legal_constraints
                    )
                    team_stats[resource.team]['total_work_hours'] += work_time

        # Calculate utilization rates
        for team, stats in team_stats.items():
            stats['utilization_rate'] = (
                stats['assigned_workers'] / stats['total_workers']
                if stats['total_workers'] > 0 else 0
            )
            stats['avg_hours_per_worker'] = (
                stats['total_work_hours'] / stats['total_workers']
                if stats['total_workers'] > 0 else 0
            )
            stats['total_work_hours'] = round(stats['total_work_hours'], 2)
            stats['avg_hours_per_worker'] = round(stats['avg_hours_per_worker'], 2)

        return dict(team_stats)

    def export_to_json(self, output_path: str):
        """Export complete solution to JSON file."""
        if not self.solution:
            print("No solution to export")
            return

        output = {
            'metadata': {
                'planning_period': {
                    'start': str(self.data.planning_start),
                    'end': str(self.data.planning_end)
                },
                'statistics': self.solution['statistics']
            },
            'schedule_by_resource': self.generate_schedule_by_resource(),
            'schedule_by_request': self.generate_schedule_by_request(),
            'daily_summary': self.generate_daily_summary(),
            'team_utilization': self.generate_team_utilization()
        }

        # Include plan_id and KPIs if present
        if 'plan_id' in self.solution:
            output['plan_id'] = self.solution['plan_id']
        if 'kpis' in self.solution:
            output['kpis'] = self.solution['kpis']

        with open(output_path, 'w') as f:
            json.dump(output, f, indent=2)

        print(f"Solution exported to: {output_path}")

    def print_summary(self):
        """Print human-readable summary to console."""
        if not self.solution:
            print("No solution available")
            return

        print("\n" + "=" * 60)
        print("SCHEDULING SOLUTION SUMMARY")
        print("=" * 60)

        # Statistics
        stats = self.solution['statistics']
        print(f"\nObjective Value: {stats['objective_value']:.2f}")
        print(f"Solve Time: {stats['solve_time']:.2f} seconds")

        # Daily summary
        print("\n" + "-" * 60)
        print("DAILY SUMMARY")
        print("-" * 60)
        daily = self.generate_daily_summary()
        for day_str, info in sorted(daily.items()):
            print(f"{day_str}: {info['total_requests']} requests, "
                  f"{info['total_workers_assigned']} workers assigned")

        # Team utilization
        print("\n" + "-" * 60)
        print("TEAM UTILIZATION")
        print("-" * 60)
        teams = self.generate_team_utilization()
        for team, stats in sorted(teams.items()):
            print(f"\n{team.upper()} Team:")
            print(f"  Workers: {stats['assigned_workers']}/{stats['total_workers']} assigned "
                  f"({stats['utilization_rate'] * 100:.1f}%)")
            print(f"  Total assignments: {stats['total_assignments']}")
            print(f"  Total work hours: {stats['total_work_hours']}h")
            print(f"  Avg hours/worker: {stats['avg_hours_per_worker']}h")

        # Request fulfillment
        print("\n" + "-" * 60)
        print("REQUEST ASSIGNMENTS")
        print("-" * 60)
        schedule = self.generate_schedule_by_request()
        for req_id, info in sorted(schedule.items()):
            print(f"\n{req_id}: {info['description']}")
            print(f"  Location: {info['location']}")
            print(f"  Date/Time: {info['date']} at {info['start_time']} ({info['duration_hours']}h)")
            print(f"  Required: {', '.join(info['required_qualifications'])}")
            print(f"  Assigned ({len(info['assigned_resources'])}/{info['people_needed']}):")
            for worker in info['assigned_resources']:
                print(f"    - {worker['name']} ({worker['team']} team, {worker['home_location']})")

        print("\n" + "=" * 60)


def export_solution(
        problem_data: ProblemData,
        solution: Optional[Dict],
        output_path: str = "solution.json"
):
    """Convenience function to export solution."""
    formatter = OutputFormatter(problem_data, solution)
    formatter.export_to_json(output_path)
    formatter.print_summary()
