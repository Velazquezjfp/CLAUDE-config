"""
Main program for CFF Maintenance Crew Scheduling System.

This solves the daily maintenance crew scheduling problem using Integer Programming
with Google OR-Tools. It handles all Swiss Labor Law constraints and provides
infeasibility diagnosis when no solution exists.

Usage:
    python main.py [options]

Options:
    --input PATH       Path to input JSON file (default: mock_data.json)
    --output PATH      Path to output JSON file (default: solution.json)
    --time-limit SECS  Solver time limit in seconds (default: 300)
    --diagnose         Run infeasibility analysis regardless of result
"""
import sys
import argparse
from ortools.init.python import init

from data_models import parse_json_data
from solver import CFFScheduler
from infeasibility_analyzer import InfeasibilityAnalyzer
from output_formatter import OutputFormatter
from kpi_calculator import KPICalculator
from datetime import datetime


def main():
    """Main entry point."""
    # Parse command line arguments
    parser = argparse.ArgumentParser(
        description='CFF Maintenance Crew Scheduling System'
    )
    parser.add_argument(
        '--input',
        type=str,
        default='mock_data.json',
        help='Path to input JSON file (default: mock_data.json)'
    )
    parser.add_argument(
        '--output',
        type=str,
        default='solution.json',
        help='Path to output JSON file (default: solution.json)'
    )
    parser.add_argument(
        '--time-limit',
        type=int,
        default=300,
        help='Solver time limit in seconds (default: 300)'
    )
    parser.add_argument(
        '--diagnose',
        action='store_true',
        help='Run infeasibility analysis regardless of result'
    )
    parser.add_argument(
        '--external',
        type=str,
        default=None,
        help='Path to external resources JSON file (optional)'
    )
    parser.add_argument(
        '--objective',
        type=str,
        choices=['cost', 'travel', 'both'],
        default='travel',
        help='Optimization objective: cost, travel, or both (default: travel)'
    )
    parser.add_argument(
        '--max-travel',
        type=int,
        default=None,
        help='Maximum travel time in minutes (hard constraint)'
    )
    parser.add_argument(
        '--team-cohesion',
        type=float,
        default=None,
        help='Minimum team cohesion percentage 0-1 (e.g., 0.5 = 50%%)'
    )

    args = parser.parse_args()

    # Initialize OR-Tools (simplified to avoid timezone issues)
    print("Initializing OR-Tools...")
    print(f"OR-Tools version: {init.OrToolsVersion.version_string()}")

    # Load problem data
    print(f"\nLoading data from: {args.input}")
    if args.external:
        print(f"External resources: {args.external}")

    try:
        problem_data = parse_json_data(args.input, external_path=args.external)

        # Count internal vs external
        internal_count = sum(1 for r in problem_data.resources if not r.is_external())
        external_count = sum(1 for r in problem_data.resources if r.is_external())

        print(f"✓ Data loaded successfully")
        print(f"  - {internal_count} internal resources")
        if external_count > 0:
            print(f"  - {external_count} external resources")
        print(f"  - {len(problem_data.requests)} requests")
        print(f"  - Planning period: {problem_data.planning_start} to {problem_data.planning_end}")
    except Exception as e:
        print(f"✗ Error loading data: {e}")
        return 1

    # Create and solve
    scheduler = CFFScheduler(problem_data)
    solution_found = scheduler.build_and_solve(time_limit=args.time_limit)

    if solution_found:
        # Solution exists - output results
        print("\n✓ Solution found!")

        solution = scheduler.get_solution()

        # Add plan_id with timestamp
        plan_id = f"plan_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        solution['plan_id'] = plan_id

        # Calculate KPIs
        kpi_calc = KPICalculator(problem_data)
        kpis = kpi_calc.calculate_kpis(solution)

        # Add KPIs to solution
        solution['kpis'] = kpis

        # Format and export
        formatter = OutputFormatter(problem_data, solution)
        formatter.export_to_json(args.output)

        # Print summary
        formatter.print_summary()

        # Print KPI summary
        print("\n" + "=" * 60)
        print("KEY PERFORMANCE INDICATORS")
        print("=" * 60)
        print(f"\nCOVERAGE:")
        print(f"  Total requests: {kpis['coverage']['total_requests']}")
        print(f"  Covered (internal only): {kpis['coverage']['covered_internal']}")
        print(f"  Covered (with external): {kpis['coverage']['covered_external']}")
        print(f"  Uncovered: {kpis['coverage']['uncovered']}")

        print(f"\nCOMPLIANCE:")
        print(f"  LDT violations: {kpis['compliance']['ldt_violations']}")
        print(f"  Skill mismatches: {kpis['compliance']['skill_mismatches']}")
        print(f"  Fatigue warnings: {kpis['compliance']['fatigue_warnings']}")

        print(f"\nEFFICIENCY:")
        print(f"  Avg travel time: {kpis['efficiency']['avg_travel_time_minutes']} minutes")
        print(f"  Total cost: {kpis['efficiency']['total_cost_chf']} CHF")
        print(f"  Team continuity: {kpis['efficiency']['team_continuity_score']}")

        print(f"\nCOST BREAKDOWN:")
        print(f"  Internal: {kpis['cost_breakdown']['internal_cost']} CHF ({kpis['cost_breakdown']['internal_hours']}h)")
        print(f"  External: {kpis['cost_breakdown']['external_cost']} CHF ({kpis['cost_breakdown']['external_hours']}h)")
        print(f"  TOTAL: {kpis['cost_breakdown']['total_cost']} CHF")

        if kpis['resource_gaps']:
            print(f"\nRESOURCE GAPS: {len(kpis['resource_gaps'])} unfilled requirements")

        print("=" * 60)

        # Run diagnosis if requested
        if args.diagnose:
            print("\nRunning infeasibility analysis (diagnostic mode)...")
            analyzer = InfeasibilityAnalyzer(problem_data)
            issues = analyzer.analyze()
            analyzer.print_report(issues)

        return 0

    else:
        # No solution - run infeasibility analysis
        print("\n✗ No feasible solution found")
        print("\nRunning infeasibility analysis to identify resource gaps...")

        analyzer = InfeasibilityAnalyzer(problem_data)
        issues = analyzer.analyze()
        analyzer.print_report(issues)

        # Recommend external resources if not already using them
        if not args.external:
            print("\n" + "=" * 60)
            print("RECOMMENDATION: TRY EXTERNAL RESOURCES")
            print("=" * 60)
            print("Run with external resources to potentially find a solution:")
            print(f"  python main.py --input {args.input} --external external_resources.json")
            print("\nExternal contractors can fill skill gaps and provide flexibility.")
            print("Note: External resources cost 50 CHF/hour vs 30 CHF/hour for internal.")
            print("=" * 60)

        # Optionally export diagnosis to JSON
        diagnosis_output = args.output.replace('.json', '_diagnosis.json')
        import json
        with open(diagnosis_output, 'w') as f:
            json.dump(issues, f, indent=2)
        print(f"\nDiagnosis exported to: {diagnosis_output}")

        return 1


if __name__ == "__main__":
    sys.exit(main())
