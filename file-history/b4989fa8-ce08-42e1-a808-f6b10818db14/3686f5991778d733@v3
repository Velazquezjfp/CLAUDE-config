"""
Data models for CFF maintenance crew scheduling problem.
Parses JSON data into structured Python objects.
"""
from dataclasses import dataclass
from datetime import datetime, date, time, timedelta
from typing import List, Dict, Tuple, Set
import json


@dataclass
class Holiday:
    """Represents a holiday period for a resource."""
    start: date
    end: date

    def contains_date(self, check_date: date) -> bool:
        """Check if a date falls within this holiday period."""
        return self.start <= check_date <= self.end


@dataclass
class Resource:
    """Represents a maintenance worker."""
    id: str
    name: str
    team: str
    home_location: str
    qualifications: Set[str]
    contract_type: str  # 'day', 'mixed', or 'night'
    weekly_hours: int
    holidays: List[Holiday]
    resource_type: str = "internal"  # 'internal' or 'external'
    cost_per_hour: float = 30.0  # CHF per hour (default internal rate)

    def is_available(self, check_date: date) -> bool:
        """Check if resource is available on a given date."""
        return not any(holiday.contains_date(check_date) for holiday in self.holidays)

    def has_qualifications(self, required_quals: Set[str]) -> bool:
        """Check if resource has all required qualifications."""
        return required_quals.issubset(self.qualifications)

    def can_work_night_shift(self) -> bool:
        """Check if resource can work night shifts."""
        return self.contract_type in ['mixed', 'night']

    def is_external(self) -> bool:
        """Check if resource is an external contractor."""
        return self.resource_type == "external"


@dataclass
class Request:
    """Represents a maintenance work request."""
    id: str
    location: str
    start_date: date
    start_time: time
    duration_hours: float
    required_qualifications: Set[str]
    people_needed: int
    description: str

    def get_start_datetime(self) -> datetime:
        """Get the full start datetime."""
        return datetime.combine(self.start_date, self.start_time)

    def get_end_datetime(self) -> datetime:
        """Get the full end datetime."""
        start_dt = self.get_start_datetime()
        return start_dt + timedelta(hours=self.duration_hours)

    def overlaps_night_shift(self, night_start: time, night_end: time) -> bool:
        """Check if request overlaps with night shift hours (23:00-06:00)."""
        start_dt = self.get_start_datetime()
        end_dt = self.get_end_datetime()

        # Check each hour of the request
        current = start_dt
        while current < end_dt:
            current_time = current.time()
            # Night shift spans midnight, so we check if time is after 23:00 OR before 06:00
            if current_time >= night_start or current_time < night_end:
                return True
            current += timedelta(hours=1)
        return False


@dataclass
class LegalConstraints:
    """Swiss Labor Law (LDT) constraints."""
    max_daily_hours: int
    max_weekly_hours: int
    min_daily_rest_hours: int
    min_weekly_rest_hours: int
    max_consecutive_workdays: int
    mandatory_break_after_hours: float
    mandatory_break_duration_minutes: int
    travel_time_counts_as_work: bool
    night_shift_start: time
    night_shift_end: time


class DistanceMatrix:
    """Handles distance lookups between locations."""

    def __init__(self, locations: List[str], matrix: List[List[float]]):
        self.locations = locations
        self.matrix = matrix
        self.location_index = {loc: idx for idx, loc in enumerate(locations)}

    def get_distance(self, from_loc: str, to_loc: str) -> float:
        """Get distance in kilometers between two locations."""
        if from_loc not in self.location_index or to_loc not in self.location_index:
            raise ValueError(f"Unknown location: {from_loc} or {to_loc}")
        from_idx = self.location_index[from_loc]
        to_idx = self.location_index[to_loc]
        return self.matrix[from_idx][to_idx]


class ProblemData:
    """Container for all problem data."""

    def __init__(
        self,
        resources: List[Resource],
        requests: List[Request],
        distance_matrix: DistanceMatrix,
        legal_constraints: LegalConstraints,
        planning_start: date,
        planning_end: date
    ):
        self.resources = resources
        self.requests = requests
        self.distance_matrix = distance_matrix
        self.legal_constraints = legal_constraints
        self.planning_start = planning_start
        self.planning_end = planning_end

        # Create lookup dictionaries
        self.resource_by_id = {r.id: r for r in resources}
        self.request_by_id = {r.id: r for r in requests}

    def get_planning_days(self) -> List[date]:
        """Get list of all days in planning period."""
        days = []
        current = self.planning_start
        while current <= self.planning_end:
            days.append(current)
            current += timedelta(days=1)
        return days


def load_external_resources(json_path: str) -> List[Resource]:
    """
    Load external contractor resources from JSON file.

    Args:
        json_path: Path to external resources JSON file

    Returns:
        List of Resource objects marked as external
    """
    with open(json_path, 'r') as f:
        data = json.load(f)

    resources = []
    for r_data in data['resources']:
        holidays = [
            Holiday(
                start=datetime.strptime(h['start'], '%Y-%m-%d').date(),
                end=datetime.strptime(h['end'], '%Y-%m-%d').date()
            )
            for h in r_data['holidays']
        ]
        resource = Resource(
            id=r_data['id'],
            name=r_data['name'],
            team=r_data['team'],
            home_location=r_data['home_location'],
            qualifications=set(r_data['qualifications']),
            contract_type=r_data['contract_type'],
            weekly_hours=r_data['weekly_hours'],
            holidays=holidays,
            resource_type=r_data.get('resource_type', 'external'),  # Default to external
            cost_per_hour=r_data.get('cost_per_hour', 50.0)  # Default external rate
        )
        resources.append(resource)

    return resources


def parse_json_data(json_path: str, external_path: str = None) -> ProblemData:
    """
    Parse JSON file into ProblemData object.

    Args:
        json_path: Path to main input JSON file (internal resources + requests)
        external_path: Optional path to external resources JSON file

    Returns:
        ProblemData object with all resources and requests
    """
    with open(json_path, 'r') as f:
        data = json.load(f)

    # Parse resources
    resources = []
    for r_data in data['resources']:
        holidays = [
            Holiday(
                start=datetime.strptime(h['start'], '%Y-%m-%d').date(),
                end=datetime.strptime(h['end'], '%Y-%m-%d').date()
            )
            for h in r_data['holidays']
        ]
        resource = Resource(
            id=r_data['id'],
            name=r_data['name'],
            team=r_data['team'],
            home_location=r_data['home_location'],
            qualifications=set(r_data['qualifications']),
            contract_type=r_data['contract_type'],
            weekly_hours=r_data['weekly_hours'],
            holidays=holidays,
            resource_type=r_data.get('resource_type', 'internal'),
            cost_per_hour=r_data.get('cost_per_hour', 30.0)
        )
        resources.append(resource)

    # Parse requests
    requests = []
    for req_data in data['requests']:
        request = Request(
            id=req_data['id'],
            location=req_data['location'],
            start_date=datetime.strptime(req_data['start_date'], '%Y-%m-%d').date(),
            start_time=datetime.strptime(req_data['start_time'], '%H:%M').time(),
            duration_hours=req_data['duration_hours'],
            required_qualifications=set(req_data['required_qualifications']),
            people_needed=req_data['people_needed'],
            description=req_data['description']
        )
        requests.append(request)

    # Parse distance matrix
    dist_data = data['distance_matrix']
    distance_matrix = DistanceMatrix(
        locations=dist_data['locations'],
        matrix=dist_data['matrix']
    )

    # Parse legal constraints
    legal_data = data['legal_constraints']
    night_shift_data = legal_data['night_shift_hours']
    legal_constraints = LegalConstraints(
        max_daily_hours=legal_data['max_daily_hours'],
        max_weekly_hours=legal_data['max_weekly_hours'],
        min_daily_rest_hours=legal_data['min_daily_rest_hours'],
        min_weekly_rest_hours=legal_data['min_weekly_rest_hours'],
        max_consecutive_workdays=legal_data['max_consecutive_workdays'],
        mandatory_break_after_hours=legal_data['mandatory_break_after_hours'],
        mandatory_break_duration_minutes=legal_data['mandatory_break_duration_minutes'],
        travel_time_counts_as_work=legal_data['travel_time_counts_as_work'],
        night_shift_start=datetime.strptime(night_shift_data['start'], '%H:%M').time(),
        night_shift_end=datetime.strptime(night_shift_data['end'], '%H:%M').time()
    )

    # Parse planning period
    planning_data = data['metadata']['planning_period']
    planning_start = datetime.strptime(planning_data['start'], '%Y-%m-%d').date()
    planning_end = datetime.strptime(planning_data['end'], '%Y-%m-%d').date()

    # Load and merge external resources if provided
    if external_path:
        external_resources = load_external_resources(external_path)
        resources.extend(external_resources)
        print(f"  Loaded {len(external_resources)} external resources")

    return ProblemData(
        resources=resources,
        requests=requests,
        distance_matrix=distance_matrix,
        legal_constraints=legal_constraints,
        planning_start=planning_start,
        planning_end=planning_end
    )
