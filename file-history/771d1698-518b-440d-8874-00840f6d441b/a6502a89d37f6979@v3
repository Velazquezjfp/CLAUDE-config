"""
Locations router - Full CRUD for locations table with pagination
Connects to EXTERNAL database (data tables)
"""
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text
from typing import List, Optional
import math

from database import get_external_db
from models import PaginatedResponse


router = APIRouter(prefix="/locations", tags=["Locations"])


@router.get("/", response_model=PaginatedResponse)
async def list_locations(
    page: int = Query(1, ge=1, description="Page number"),
    per_page: int = Query(50, ge=1, le=200, description="Items per page"),
    canton: Optional[str] = Query(None, description="Filter by canton"),
    location_name: Optional[str] = Query(None, description="Search by location name (partial match)"),
    db: AsyncSession = Depends(get_external_db),
):
    """
    List all locations with pagination and optional filters.
    Data comes from external database.
    """
    try:
        offset = (page - 1) * per_page

        # Build WHERE clause dynamically
        where_clauses = []
        params = {"limit": per_page, "offset": offset}

        if canton:
            where_clauses.append("canton = :canton")
            params["canton"] = canton

        if location_name:
            where_clauses.append("location_name ILIKE :location_name")
            params["location_name"] = f"%{location_name}%"

        where_sql = f"WHERE {' AND '.join(where_clauses)}" if where_clauses else ""

        # Count total
        count_query = text(f"SELECT COUNT(*) as total FROM locations {where_sql}")
        count_result = await db.execute(count_query, params)
        total = count_result.scalar()

        # Fetch locations
        query = text(f"""
            SELECT
                location_id, location_name, location_code, canton,
                latitude, longitude,
                created_at, created_by, updated_at, updated_by
            FROM locations
            {where_sql}
            ORDER BY location_name
            LIMIT :limit OFFSET :offset
        """)

        result = await db.execute(query, params)
        rows = result.fetchall()

        locations = [dict(row._mapping) for row in rows]

        total_pages = math.ceil(total / per_page) if total > 0 else 0

        return PaginatedResponse(
            total=total,
            page=page,
            per_page=per_page,
            total_pages=total_pages,
            data=locations,
        )

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching locations: {str(e)}",
        )


@router.get("/{location_id}")
async def get_location(
    location_id: int,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Get a single location by ID.
    Data comes from external database.
    """
    try:
        query = text("""
            SELECT
                location_id, location_name, location_code, canton,
                latitude, longitude,
                created_at, created_by, updated_at, updated_by
            FROM locations
            WHERE location_id = :location_id
        """)

        result = await db.execute(query, {"location_id": location_id})
        row = result.fetchone()

        if not row:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Location with ID {location_id} not found",
            )

        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching location: {str(e)}",
        )


@router.post("/", status_code=status.HTTP_201_CREATED)
async def create_location(
    location: dict,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Create a new location in external database.
    Required fields: location_name
    """
    try:
        # Validate required fields
        if "location_name" not in location or not location["location_name"]:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Missing required field: location_name",
            )

        # Check if location_name already exists
        check_query = text("SELECT location_id FROM locations WHERE location_name = :location_name")
        check_result = await db.execute(check_query, {"location_name": location["location_name"]})
        if check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Location with name {location['location_name']} already exists",
            )

        insert_query = text("""
            INSERT INTO locations (location_name, location_code, canton, latitude, longitude, created_by)
            VALUES (:location_name, :location_code, :canton, :latitude, :longitude, :created_by)
            RETURNING location_id, location_name, location_code, canton, latitude, longitude,
                      created_at, created_by, updated_at, updated_by
        """)

        result = await db.execute(
            insert_query,
            {
                "location_name": location.get("location_name"),
                "location_code": location.get("location_code"),
                "canton": location.get("canton"),
                "latitude": location.get("latitude"),
                "longitude": location.get("longitude"),
                "created_by": location.get("created_by", "api"),
            },
        )

        await db.commit()
        row = result.fetchone()
        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating location: {str(e)}",
        )


@router.put("/{location_id}")
async def update_location(
    location_id: int,
    location: dict,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Update an existing location in external database.
    """
    try:
        # Check if location exists
        check_query = text("SELECT location_id FROM locations WHERE location_id = :location_id")
        check_result = await db.execute(check_query, {"location_id": location_id})
        if not check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Location with ID {location_id} not found",
            )

        # Build UPDATE clause dynamically
        update_fields = []
        params = {"location_id": location_id}

        if "location_name" in location and location["location_name"] is not None:
            update_fields.append("location_name = :location_name")
            params["location_name"] = location["location_name"]

        if "location_code" in location and location["location_code"] is not None:
            update_fields.append("location_code = :location_code")
            params["location_code"] = location["location_code"]

        if "canton" in location and location["canton"] is not None:
            update_fields.append("canton = :canton")
            params["canton"] = location["canton"]

        if "latitude" in location and location["latitude"] is not None:
            update_fields.append("latitude = :latitude")
            params["latitude"] = location["latitude"]

        if "longitude" in location and location["longitude"] is not None:
            update_fields.append("longitude = :longitude")
            params["longitude"] = location["longitude"]

        # Add updated_by
        update_fields.append("updated_by = :updated_by")
        params["updated_by"] = location.get("updated_by", "api")

        if not update_fields:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="No fields to update",
            )

        update_query = text(f"""
            UPDATE locations
            SET {', '.join(update_fields)}
            WHERE location_id = :location_id
            RETURNING location_id, location_name, location_code, canton, latitude, longitude,
                      created_at, created_by, updated_at, updated_by
        """)

        result = await db.execute(update_query, params)
        await db.commit()

        row = result.fetchone()
        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error updating location: {str(e)}",
        )


@router.delete("/{location_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_location(
    location_id: int,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Delete a location from external database.
    """
    try:
        # Check if location exists
        check_query = text("SELECT location_id FROM locations WHERE location_id = :location_id")
        check_result = await db.execute(check_query, {"location_id": location_id})
        if not check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Location with ID {location_id} not found",
            )

        delete_query = text("DELETE FROM locations WHERE location_id = :location_id")
        await db.execute(delete_query, {"location_id": location_id})
        await db.commit()

        return None

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error deleting location: {str(e)}",
        )
