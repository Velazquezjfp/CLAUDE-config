"""
Operation Points router - Full CRUD for operation_points table
Connects to EXTERNAL database (data tables)
Note: Railway operational points with station info, line numbers, and km markers
"""
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text
from typing import List, Optional
import math

from database import get_external_db


router = APIRouter(prefix="/operation-points", tags=["Operation Points"])


@router.get("/")
async def list_operation_points(
    line_number: Optional[str] = Query(None, description="Filter by line number"),
    station_code: Optional[str] = Query(None, description="Filter by station code"),
    team_id: Optional[int] = Query(None, description="Filter by team ID"),
    page: int = Query(1, ge=1, description="Page number"),
    per_page: int = Query(50, ge=1, le=200, description="Items per page"),
    db: AsyncSession = Depends(get_external_db),
):
    """
    List all operation points with pagination and optional filters.
    Data comes from external database.
    """
    try:
        # Build WHERE clause
        conditions = []
        params = {}

        if line_number:
            conditions.append("line_number = :line_number")
            params["line_number"] = line_number

        if station_code:
            conditions.append("station_code ILIKE :station_code")
            params["station_code"] = f"%{station_code}%"

        if team_id:
            conditions.append("team_id = :team_id")
            params["team_id"] = team_id

        where_clause = "WHERE " + " AND ".join(conditions) if conditions else ""

        # Count query
        count_query = text(f"SELECT COUNT(*) FROM operation_points {where_clause}")
        count_result = await db.execute(count_query, params)
        total = count_result.scalar()

        # Calculate pagination
        total_pages = math.ceil(total / per_page) if total > 0 else 1
        offset = (page - 1) * per_page

        # Data query
        query = text(f"""
            SELECT operation_points_id, station_name, station_code, line_number, km,
                   team_id, created_at, created_by, updated_at, updated_by
            FROM operation_points
            {where_clause}
            ORDER BY line_number, km
            LIMIT :limit OFFSET :offset
        """)

        params["limit"] = per_page
        params["offset"] = offset

        result = await db.execute(query, params)
        rows = result.fetchall()

        return {
            "total": total,
            "page": page,
            "per_page": per_page,
            "total_pages": total_pages,
            "data": [dict(row._mapping) for row in rows],
        }

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching operation points: {str(e)}",
        )


@router.get("/{operation_points_id}")
async def get_operation_point(
    operation_points_id: int,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Get a single operation point by ID.
    Data comes from external database.
    """
    try:
        query = text("""
            SELECT operation_points_id, station_name, station_code, line_number, km,
                   team_id, created_at, created_by, updated_at, updated_by
            FROM operation_points
            WHERE operation_points_id = :operation_points_id
        """)

        result = await db.execute(query, {"operation_points_id": operation_points_id})
        row = result.fetchone()

        if not row:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Operation point with ID {operation_points_id} not found",
            )

        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching operation point: {str(e)}",
        )


@router.get("/line/{line_number}")
async def get_operation_points_by_line(
    line_number: str,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Get all operation points for a specific line, ordered by km.
    Data comes from external database.
    """
    try:
        query = text("""
            SELECT operation_points_id, station_name, station_code, line_number, km,
                   team_id, created_at, created_by, updated_at, updated_by
            FROM operation_points
            WHERE line_number = :line_number
            ORDER BY km
        """)

        result = await db.execute(query, {"line_number": line_number})
        rows = result.fetchall()

        return [dict(row._mapping) for row in rows]

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching operation points for line {line_number}: {str(e)}",
        )


@router.post("/", status_code=status.HTTP_201_CREATED)
async def create_operation_point(
    operation_point: dict,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Create a new operation point in external database.
    Required fields: station_name, station_code, line_number
    """
    try:
        # Validate required fields
        required_fields = ["station_name", "station_code", "line_number"]
        for field in required_fields:
            if field not in operation_point or not operation_point[field]:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Missing required field: {field}",
                )

        insert_query = text("""
            INSERT INTO operation_points (station_name, station_code, line_number, km, team_id, created_by)
            VALUES (:station_name, :station_code, :line_number, :km, :team_id, :created_by)
            RETURNING operation_points_id, station_name, station_code, line_number, km,
                      team_id, created_at, created_by, updated_at, updated_by
        """)

        result = await db.execute(
            insert_query,
            {
                "station_name": operation_point.get("station_name"),
                "station_code": operation_point.get("station_code"),
                "line_number": operation_point.get("line_number"),
                "km": operation_point.get("km"),
                "team_id": operation_point.get("team_id"),
                "created_by": operation_point.get("created_by", "api"),
            },
        )

        await db.commit()
        row = result.fetchone()
        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating operation point: {str(e)}",
        )


@router.put("/{operation_points_id}")
async def update_operation_point(
    operation_points_id: int,
    operation_point: dict,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Update an existing operation point in external database.
    """
    try:
        # Check if operation point exists
        check_query = text("SELECT operation_points_id FROM operation_points WHERE operation_points_id = :operation_points_id")
        check_result = await db.execute(check_query, {"operation_points_id": operation_points_id})
        if not check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Operation point with ID {operation_points_id} not found",
            )

        # Build UPDATE clause dynamically
        update_fields = []
        params = {"operation_points_id": operation_points_id}

        if "station_name" in operation_point and operation_point["station_name"] is not None:
            update_fields.append("station_name = :station_name")
            params["station_name"] = operation_point["station_name"]

        if "station_code" in operation_point and operation_point["station_code"] is not None:
            update_fields.append("station_code = :station_code")
            params["station_code"] = operation_point["station_code"]

        if "line_number" in operation_point and operation_point["line_number"] is not None:
            update_fields.append("line_number = :line_number")
            params["line_number"] = operation_point["line_number"]

        if "km" in operation_point:
            update_fields.append("km = :km")
            params["km"] = operation_point["km"]

        if "team_id" in operation_point:
            update_fields.append("team_id = :team_id")
            params["team_id"] = operation_point["team_id"]

        # Add updated_by
        update_fields.append("updated_by = :updated_by")
        params["updated_by"] = operation_point.get("updated_by", "api")

        if not update_fields:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="No fields to update",
            )

        update_query = text(f"""
            UPDATE operation_points
            SET {', '.join(update_fields)}
            WHERE operation_points_id = :operation_points_id
            RETURNING operation_points_id, station_name, station_code, line_number, km,
                      team_id, created_at, created_by, updated_at, updated_by
        """)

        result = await db.execute(update_query, params)
        await db.commit()

        row = result.fetchone()
        return dict(row._mapping)

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error updating operation point: {str(e)}",
        )


@router.delete("/{operation_points_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_operation_point(
    operation_points_id: int,
    db: AsyncSession = Depends(get_external_db),
):
    """
    Delete an operation point from external database.
    """
    try:
        # Check if operation point exists
        check_query = text("SELECT operation_points_id FROM operation_points WHERE operation_points_id = :operation_points_id")
        check_result = await db.execute(check_query, {"operation_points_id": operation_points_id})
        if not check_result.fetchone():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Operation point with ID {operation_points_id} not found",
            )

        delete_query = text("DELETE FROM operation_points WHERE operation_points_id = :operation_points_id")
        await db.execute(delete_query, {"operation_points_id": operation_points_id})
        await db.commit()

        return None

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error deleting operation point: {str(e)}",
        )
