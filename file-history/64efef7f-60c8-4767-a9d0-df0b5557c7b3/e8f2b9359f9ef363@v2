# Analysis System Methodology

## Overview

The analysis system provides comprehensive post-solve metrics and recommendations. It follows a **modular plugin architecture** where each constraint and objective has its own analyzer module.

**Key Principles:**
- ðŸ”§ **Modular**: Each constraint/objective has its own analyzer
- ðŸ“– **Self-documenting**: This guide explains how to add new analyzers
- ðŸŽ¯ **Actionable**: Provides specific, implementable recommendations
- ðŸ”¬ **Multi-constraint aware**: Considers all constraints when suggesting actions
- âš–ï¸ **Weight-aware**: Suggests which weights to adjust for better results

## Architecture

```
analysis/
â”œâ”€â”€ constraint_analyzers/       # One analyzer per constraint
â”‚   â”œâ”€â”€ base_analyzer.py       # Abstract base class (DO NOT MODIFY)
â”‚   â”œâ”€â”€ lc_01_analyzer.py      # Weekly hours analysis
â”‚   â”œâ”€â”€ lc_02_analyzer.py      # 14h span analysis
â”‚   â””â”€â”€ ...                    # More constraint analyzers
â”œâ”€â”€ objective_analyzers/        # One analyzer per objective
â”‚   â”œâ”€â”€ base_analyzer.py       # Abstract base class (DO NOT MODIFY)
â”‚   â”œâ”€â”€ coverage_analyzer.py   # Coverage gap analysis
â”‚   â””â”€â”€ workload_analyzer.py   # Workload distribution analysis
â”œâ”€â”€ recommendations/
â”‚   â”œâ”€â”€ training_analyzer.py   # Multi-constraint training impact
â”‚   â””â”€â”€ capacity_analyzer.py   # Resource capacity analysis
â”œâ”€â”€ solution_analyzer.py        # Main orchestrator
â””â”€â”€ ANALYSIS_METHODOLOGY.md     # This file
```

---

## Adding a New Constraint Analyzer

When you add a new constraint (e.g., `LC_05_min_daily_rest`), follow these steps to enable full analysis support.

### Step 1: Update Constraint Module to Return Metadata

**File:** `constraints/lc_05_min_daily_rest.py`

Modify the constraint function to return **both violations and metadata**:

```python
def add_daily_rest_constraints(model: cp_model.CpModel,
                               x_vars: dict,
                               data,
                               constraints) -> tuple:
    """
    Returns:
        (violations, metadata) tuple
    """
    violations = []
    violation_metadata = []  # NEW: Track metadata

    MIN_REST_LEGAL = constraints.get_legal_value('min_rest_hours_daily')
    MIN_REST_COMPANY = constraints.get_company_value('min_rest_company_daily')

    for resource_id in data.resource_ids:
        # ... constraint logic ...

        if USE_SOFT_CONSTRAINTS:
            violation_var = model.NewIntVar(...)
            violations.append(violation_var)

            # NEW: Store metadata for analysis
            violation_metadata.append({
                'constraint_id': 'LC_05',
                'constraint_name': 'min_daily_rest',
                'violation_var_name': violation_var.Name(),
                'resource_id': resource_id,
                'shift_pair': (req_i_id, req_j_id),  # Context-specific
                'rest_hours': rest_hours,
                'legal_limit': MIN_REST_LEGAL,
                'company_limit': MIN_REST_COMPANY,
                'affected_assignments': [req_i_id, req_j_id]
            })

    return violations, violation_metadata  # Return tuple!
```

**Key Points:**
- Always return a tuple: `(violations, metadata)`
- Metadata is a list of dicts
- Include `constraint_id`, `constraint_name`, `violation_var_name`
- Add constraint-specific context (e.g., `week`, `day`, `shift_pair`)
- Include limits and affected assignments

### Step 2: Create Analyzer Module

**File:** `analysis/constraint_analyzers/lc_05_analyzer.py`

```python
"""
LC_05: Minimum Daily Rest Analyzer
Analyzes violations of minimum rest periods between shifts
"""
from .base_analyzer import ConstraintAnalyzer
from datetime import datetime
import sys
sys.path.append('../..')
from config import SCALING_FACTOR


class LC_05_Analyzer(ConstraintAnalyzer):
    """Analyzer for LC_05 (minimum daily rest)"""

    def __init__(self):
        super().__init__(
            constraint_id='LC_05',
            constraint_name='min_daily_rest'
        )

    def analyze_violations(self, solution, data, constraints, violation_metadata):
        """
        Analyze minimum daily rest violations

        Args:
            solution: Solved model with assignments
            data: PreprocessedData object
            constraints: ConstraintValues object
            violation_metadata: List of metadata from constraint module

        Returns:
            Detailed violation analysis dict
        """
        # Filter metadata for this constraint
        my_violations = [
            v for v in violation_metadata
            if v['constraint_id'] == 'LC_05'
        ]

        if not my_violations:
            return {
                "constraint_id": "LC_05",
                "constraint_name": "min_daily_rest",
                "total_violations": 0,
                "message": "No violations detected"
            }

        # Group by resource
        violations_by_resource = {}
        total_violation_amount = 0

        for viol_meta in my_violations:
            # Get violation value from solver
            viol_var_name = viol_meta['violation_var_name']
            # Find variable in solution
            violation_value = self._get_violation_value(solution, viol_var_name)

            if violation_value == 0:
                continue  # No actual violation

            violation_amount = violation_value / SCALING_FACTOR
            total_violation_amount += violation_amount

            resource_id = viol_meta['resource_id']
            if resource_id not in violations_by_resource:
                violations_by_resource[resource_id] = []

            # Calculate actual rest hours
            rest_hours = viol_meta['rest_hours']
            shortage = viol_meta['company_limit'] - rest_hours

            violations_by_resource[resource_id].append({
                'context': {
                    'shift_pair': viol_meta['shift_pair'],
                    'rest_hours': rest_hours
                },
                'legal_limit': viol_meta['legal_limit'],
                'company_limit': viol_meta['company_limit'],
                'actual_value': rest_hours,
                'violation_amount': shortage,
                'severity': self.classify_severity(
                    shortage,
                    viol_meta['legal_limit'],
                    viol_meta['company_limit']
                ),
                'affected_assignments': viol_meta['affected_assignments'],
                'how_to_fix': self._generate_fix_suggestions(
                    viol_meta, data
                )
            })

        # Build severity breakdown
        severity_breakdown = {"LOW": 0, "MEDIUM": 0, "HIGH": 0}
        for resource_viols in violations_by_resource.values():
            for v in resource_viols:
                severity_breakdown[v['severity']] += 1

        # Format detailed violations
        detailed_violations = [
            {
                'resource_id': resource_id,
                'total_violations': len(viols),
                'violations': viols
            }
            for resource_id, viols in violations_by_resource.items()
        ]

        return {
            "constraint_id": "LC_05",
            "constraint_name": "min_daily_rest",
            "total_violations": len(my_violations),
            "total_violation_amount": total_violation_amount,
            "affected_resources": len(violations_by_resource),
            "severity_breakdown": severity_breakdown,
            "detailed_violations": detailed_violations
        }

    def check_would_violate(self, simulated_assignment, existing_assignments,
                           data, constraints):
        """
        Check if adding this assignment would violate rest requirements
        """
        MIN_REST_LEGAL = constraints.get_legal_value('min_rest_hours_daily')
        MIN_REST_COMPANY = constraints.get_company_value('min_rest_company_daily')

        sim_start = datetime.fromisoformat(simulated_assignment['start'])
        sim_end = datetime.fromisoformat(simulated_assignment['end'])

        # Check rest before and after this assignment
        for existing in existing_assignments:
            exist_start = datetime.fromisoformat(existing['start'])
            exist_end = datetime.fromisoformat(existing['end'])

            # Rest before new assignment
            if exist_end < sim_start:
                rest_hours = (sim_start - exist_end).total_seconds() / 3600
                if rest_hours < MIN_REST_LEGAL:
                    return {
                        "would_violate": True,
                        "violation_type": "legal",
                        "violation_amount": MIN_REST_LEGAL - rest_hours,
                        "reason": f"Only {rest_hours:.1f}h rest between shifts (legal: {MIN_REST_LEGAL}h)",
                        "details": {
                            "previous_assignment": existing['request_id'],
                            "rest_hours": rest_hours
                        }
                    }
                elif rest_hours < MIN_REST_COMPANY:
                    return {
                        "would_violate": True,
                        "violation_type": "company",
                        "violation_amount": MIN_REST_COMPANY - rest_hours,
                        "reason": f"Only {rest_hours:.1f}h rest between shifts (company: {MIN_REST_COMPANY}h)",
                        "details": {
                            "previous_assignment": existing['request_id'],
                            "rest_hours": rest_hours
                        }
                    }

            # Rest after new assignment
            if sim_end < exist_start:
                rest_hours = (exist_start - sim_end).total_seconds() / 3600
                if rest_hours < MIN_REST_LEGAL:
                    return {
                        "would_violate": True,
                        "violation_type": "legal",
                        "violation_amount": MIN_REST_LEGAL - rest_hours,
                        "reason": f"Only {rest_hours:.1f}h rest before next shift (legal: {MIN_REST_LEGAL}h)",
                        "details": {
                            "next_assignment": existing['request_id'],
                            "rest_hours": rest_hours
                        }
                    }
                elif rest_hours < MIN_REST_COMPANY:
                    return {
                        "would_violate": True,
                        "violation_type": "company",
                        "violation_amount": MIN_REST_COMPANY - rest_hours,
                        "reason": f"Only {rest_hours:.1f}h rest before next shift (company: {MIN_REST_COMPANY}h)",
                        "details": {
                            "next_assignment": existing['request_id'],
                            "rest_hours": rest_hours
                        }
                    }

        return {
            "would_violate": False,
            "violation_type": "none",
            "violation_amount": 0,
            "reason": "Sufficient rest periods maintained"
        }

    def suggest_weight_adjustment(self, violations):
        """Suggest weight adjustments"""
        total_viols = violations.get('total_violations', 0)

        if total_viols == 0:
            return {
                "constraint_id": "LC_05",
                "current_weight": 1000,
                "suggested_adjustments": []
            }

        suggestions = []

        if total_viols > 100:
            suggestions.append({
                "new_weight": 1500,
                "expected_impact": "Stronger enforcement of rest periods",
                "trade_offs": "May reduce coverage by 2-5% as more assignments become infeasible"
            })

        if total_viols < 50:
            suggestions.append({
                "new_weight": 700,
                "expected_impact": "More flexibility with rest periods",
                "trade_offs": "May increase coverage by 1-3% but reduce worker rest quality"
            })

        return {
            "constraint_id": "LC_05",
            "current_weight": 1000,
            "suggested_adjustments": suggestions
        }

    def _get_violation_value(self, solution, var_name):
        """Extract violation value from solution"""
        # This would need to access the solver's variable values
        # For now, return placeholder
        return 0

    def _generate_fix_suggestions(self, violation_meta, data):
        """Generate specific fix suggestions"""
        shift_pair = violation_meta['shift_pair']
        return [
            f"Increase gap between {shift_pair[0]} and {shift_pair[1]}",
            f"Reassign one of the shifts to a different resource",
            "Accept violation if operationally necessary (within legal limit)"
        ]
```

### Step 3: Register Analyzer

**File:** `analysis/solution_analyzer.py`

Add your analyzer to the registry:

```python
from .constraint_analyzers.lc_05_analyzer import LC_05_Analyzer

# In __init__ or get_analyzers() method:
self.constraint_analyzers = {
    'LC_01_max_weekly_hours': LC_01_Analyzer(),
    'LC_02_max_daily_hours_14h_span': LC_02_Analyzer(),
    'LC_03_max_absolute_daily_hours': LC_03_Analyzer(),
    'LC_04_max_continuous_work': LC_04_Analyzer(),
    'LC_05_min_daily_rest': LC_05_Analyzer(),  # ADD HERE
    'CP_02_qualification_matching': CP_02_Analyzer(),
}
```

### Step 4: Test Your Analyzer

Run analysis to verify:
```bash
python main.py
# Check output/analysis_report.json for LC_05 section
```

---

## Adding a New Objective Analyzer

Similar process for objectives (e.g., `minimize_idle_time`):

### Step 1: Create Analyzer Module

**File:** `analysis/objective_analyzers/idle_time_analyzer.py`

```python
"""
Idle Time Objective Analyzer
Analyzes resource idle time and utilization
"""
from .base_analyzer import ObjectiveAnalyzer


class IdleTimeAnalyzer(ObjectiveAnalyzer):
    """Analyzer for minimize_idle_time objective"""

    def __init__(self):
        super().__init__(
            objective_id='minimize_idle_time',
            objective_name='Minimize Resource Idle Time'
        )

    def analyze_performance(self, solution, data, constraints):
        """Analyze idle time performance"""
        # Calculate utilization for each resource
        total_idle_time = 0
        resource_utilization = {}

        for resource in data.resources:
            res_id = resource['resource_id']
            assignments = [
                a for a in solution.assignments
                if a['resource_id'] == res_id
            ]

            total_hours = sum(a['duration_hours'] for a in assignments)
            max_capacity = self._calculate_max_capacity(resource, data, constraints)
            idle_time = max_capacity - total_hours
            utilization_rate = (total_hours / max_capacity * 100) if max_capacity > 0 else 0

            total_idle_time += idle_time
            resource_utilization[res_id] = {
                'total_hours': total_hours,
                'max_capacity': max_capacity,
                'idle_time': idle_time,
                'utilization_rate': utilization_rate
            }

        # Calculate achievement (lower idle time is better)
        total_capacity = sum(u['max_capacity'] for u in resource_utilization.values())
        total_used = total_capacity - total_idle_time
        achievement_rate = (total_used / total_capacity * 100) if total_capacity > 0 else 0

        return {
            "objective_id": "minimize_idle_time",
            "objective_name": "Minimize Resource Idle Time",
            "target_description": "Maximize resource utilization",
            "achieved_value": total_idle_time,
            "max_possible_value": total_capacity,
            "achievement_rate": achievement_rate,
            "performance_category": self.classify_performance(achievement_rate),
            "gaps": self.get_gap_details(solution, data),
            "metrics": {
                "total_idle_hours": total_idle_time,
                "average_utilization": achievement_rate,
                "idle_resources": [
                    res_id for res_id, util in resource_utilization.items()
                    if util['utilization_rate'] == 0
                ],
                "underutilized_resources": [
                    res_id for res_id, util in resource_utilization.items()
                    if 0 < util['utilization_rate'] < 50
                ]
            }
        }

    def get_gap_details(self, solution, data):
        """Get details about utilization gaps"""
        gaps = []
        # ... implementation ...
        return gaps
```

### Step 2: Register Objective Analyzer

**File:** `analysis/solution_analyzer.py`

```python
from .objective_analyzers.idle_time_analyzer import IdleTimeAnalyzer

self.objective_analyzers = {
    'maximize_coverage': CoverageAnalyzer(),
    'balance_workload': WorkloadAnalyzer(),
    'minimize_idle_time': IdleTimeAnalyzer(),  # ADD HERE
}
```

---

## Output Format Standards

### Violation Detail Structure

All constraint analyzers must return violations in this format:

```json
{
  "constraint_id": "LC_XX",
  "constraint_name": "constraint_name",
  "total_violations": 150,
  "total_violation_amount": 225.5,
  "affected_resources": 12,
  "severity_breakdown": {
    "LOW": 100,
    "MEDIUM": 40,
    "HIGH": 10
  },
  "detailed_violations": [
    {
      "resource_id": "RES-INT-0040",
      "total_violations": 3,
      "violations": [
        {
          "context": {
            "week": "2025-W50"
          },
          "legal_limit": 50,
          "company_limit": 45,
          "actual_value": 48,
          "violation_amount": 3,
          "severity": "MEDIUM",
          "affected_assignments": ["REQ-X", "REQ-Y"],
          "how_to_fix": [
            "Remove assignment REQ-Y to reduce to 39h",
            "Reassign REQ-Y to RES-INT-0025 (18h available)"
          ]
        }
      ]
    }
  ]
}
```

### Objective Performance Structure

All objective analyzers must return performance in this format:

```json
{
  "objective_id": "objective_name",
  "objective_name": "Human Readable Name",
  "target_description": "What we're trying to achieve",
  "achieved_value": 43,
  "max_possible_value": 50,
  "achievement_rate": 86.0,
  "performance_category": "GOOD",
  "gaps": [
    {
      "gap_type": "QUALIFICATION_GAP",
      "description": "7 requests uncovered due to qualification requirements",
      "impact": "14% coverage loss",
      "recommendations": [
        "Train RES-INT-0025 on FORKLIFT",
        "Hire resource with [NIGHT_SHIFT, FORKLIFT]"
      ]
    }
  ],
  "metrics": {
    "specific_metric_1": value,
    "specific_metric_2": value
  }
}
```

---

## Best Practices

### 1. Keep Analyzers Independent
- Each analyzer should work standalone
- Don't depend on other analyzers' results
- Use only data, constraints, and solution as inputs

### 2. Provide Actionable Suggestions
- Be specific: "Remove REQ-X" not "Reduce assignments"
- Include alternatives: "Option 1: ..., Option 2: ..."
- Explain trade-offs clearly

### 3. Use Severity Classification
- LOW: < 10% over company limit
- MEDIUM: 10-20% over company limit
- HIGH: > 20% over company limit

### 4. Context is Key
- Include enough context to understand the violation
- Reference specific weeks, days, shift pairs, etc.
- Show which assignments are involved

### 5. Test Thoroughly
- Test with violations present
- Test with no violations
- Test edge cases (all resources violated, single resource violated, etc.)

---

## Troubleshooting

### "Analyzer not found" error
- Check that analyzer is registered in `solution_analyzer.py`
- Verify import path is correct
- Ensure `__init__.py` files exist in all directories

### Violation metadata is empty
- Verify constraint module returns tuple: `(violations, metadata)`
- Check that metadata list is populated in constraint module
- Ensure `solver/model.py` collects metadata

### check_would_violate() always returns False
- Verify you're checking against correct limits
- Ensure datetime parsing is correct
- Test with known violation scenarios

---

## Summary Checklist

When adding a new constraint analyzer:
- [ ] Update constraint module to return `(violations, metadata)` tuple
- [ ] Create analyzer class inheriting from `ConstraintAnalyzer`
- [ ] Implement `analyze_violations()` method
- [ ] Implement `check_would_violate()` method
- [ ] Implement `suggest_weight_adjustment()` method
- [ ] Register analyzer in `solution_analyzer.py`
- [ ] Test with `python main.py`
- [ ] Verify output in `output/analysis_report.json`

When adding a new objective analyzer:
- [ ] Create analyzer class inheriting from `ObjectiveAnalyzer`
- [ ] Implement `analyze_performance()` method
- [ ] Implement `get_gap_details()` method
- [ ] Register analyzer in `solution_analyzer.py`
- [ ] Test with `python main.py`
- [ ] Verify output in `output/analysis_report.json`
