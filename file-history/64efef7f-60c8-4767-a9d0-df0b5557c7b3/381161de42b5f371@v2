# Analysis System Implementation Status

## ‚úÖ Completed Components

### 1. Core Infrastructure
- ‚úÖ Directory structure created
- ‚úÖ Base analyzer classes (ConstraintAnalyzer, ObjectiveAnalyzer)
- ‚úÖ Comprehensive methodology guide (ANALYSIS_METHODOLOGY.md)

### 2. Constraint Modules Updated
All constraint modules now return `(violations, metadata)` tuples:
- ‚úÖ LC_01_max_weekly_hours.py
- ‚úÖ LC_02_daily_14h_span.py
- ‚úÖ LC_03_absolute_daily.py
- ‚úÖ LC_04_continuous_work.py
- ‚úÖ CP_02_qualification_matching.py

### 3. Solver Model Updated
- ‚úÖ Added `self.violation_metadata = []` to collect metadata
- ‚úÖ Updated all constraint calls to unpack `(viols, metadata)` tuples
- ‚úÖ Metadata collection active

### 4. Example Analyzers Created
- ‚úÖ **lc_01_analyzer.py** - Complete working example for weekly hours
- ‚úÖ **coverage_analyzer.py** - Complete working example for coverage objective

## üîÑ Remaining Work

### 1. Create Remaining Constraint Analyzers

**Pattern:** Follow `lc_01_analyzer.py` as template

**Files to create:**
```
analysis/constraint_analyzers/
‚îú‚îÄ‚îÄ lc_02_analyzer.py  # 14h span analysis
‚îú‚îÄ‚îÄ lc_03_analyzer.py  # Absolute daily hours analysis
‚îú‚îÄ‚îÄ lc_04_analyzer.py  # Continuous work analysis (simple - no violations)
‚îî‚îÄ‚îÄ cp_02_analyzer.py  # Qualification matching analysis
```

**Quick implementation guide for each:**

1. Copy `lc_01_analyzer.py` structure
2. Update `constraint_id` and `constraint_name` in `__init__`
3. Modify `analyze_violations()`:
   - Filter for your constraint: `v['constraint_id'] == 'LC_XX'`
   - Update context (week ‚Üí day, window, etc.)
   - Adjust calculation logic for your constraint type
4. Modify `check_would_violate()`:
   - Update limit fetching
   - Adjust time period calculation (week ‚Üí day, window)
   - Update reason messages
5. Keep `suggest_weight_adjustment()` similar pattern

**Special cases:**
- **LC_04:** Very simple - typically no violations (breaks external)
- **CP_02:** Hard constraint - analyze blocked assignments, near-matches

### 2. Create Remaining Objective Analyzers

**Pattern:** Follow `coverage_analyzer.py` as template

**Files to create:**
```
analysis/objective_analyzers/
‚îî‚îÄ‚îÄ workload_analyzer.py  # Workload balance analysis
```

**Implementation for workload_analyzer.py:**

```python
"""
Workload Balance Objective Analyzer
Analyzes workload distribution across resources
"""
from .base_analyzer import ObjectiveAnalyzer

class WorkloadAnalyzer(ObjectiveAnalyzer):
    def __init__(self):
        super().__init__(
            objective_id='balance_workload',
            objective_name='Balance Workload Distribution'
        )

    def analyze_performance(self, solution, data, constraints):
        # Calculate workload per resource
        workload = {}
        for resource in data.resources:
            res_id = resource['resource_id']
            total_hours = sum(
                a['duration_hours']
                for a in solution.assignments
                if a['resource_id'] == res_id
            )
            workload[res_id] = total_hours

        # Calculate statistics
        hours = list(workload.values())
        avg_hours = sum(hours) / len(hours) if hours else 0
        max_hours = max(hours) if hours else 0
        min_hours = min(hours) if hours else 0
        variance = max_hours - min_hours

        # Lower variance = better balance
        target_variance = 5  # Max 5 hours difference ideal
        achievement_rate = max(0, (1 - variance / target_variance) * 100)

        return {
            "objective_id": "balance_workload",
            "objective_name": "Balance Workload Distribution",
            "target_description": "Minimize workload variance across resources",
            "achieved_value": variance,
            "max_possible_value": target_variance,
            "achievement_rate": round(achievement_rate, 2),
            "performance_category": self.classify_performance(achievement_rate),
            "gaps": self.get_gap_details(solution, data, workload),
            "metrics": {
                "average_hours": round(avg_hours, 2),
                "max_hours": round(max_hours, 2),
                "min_hours": round(min_hours, 2),
                "variance": round(variance, 2),
                "overloaded_resources": [
                    res_id for res_id, hours in workload.items()
                    if hours > avg_hours * 1.2
                ],
                "underutilized_resources": [
                    res_id for res_id, hours in workload.items()
                    if hours < avg_hours * 0.5
                ]
            }
        }

    def get_gap_details(self, solution, data, workload):
        gaps = []
        avg_hours = sum(workload.values()) / len(workload) if workload else 0

        overloaded = [
            (res_id, hours)
            for res_id, hours in workload.items()
            if hours > avg_hours * 1.2
        ]

        if overloaded:
            gaps.append({
                "gap_type": "WORKLOAD_IMBALANCE",
                "description": f"{len(overloaded)} resources overloaded (>20% above average)",
                "impact": "Reduced worker satisfaction, increased fatigue risk",
                "recommendations": [
                    f"Redistribute assignments from {res_id} ({hours:.1f}h)"
                    for res_id, hours in sorted(overloaded, key=lambda x: x[1], reverse=True)[:3]
                ]
            })

        return gaps
```

### 3. Create Training Analyzer (Multi-Constraint Aware)

**File:** `analysis/recommendations/training_analyzer.py`

**Purpose:** Analyze training impact considering ALL enabled constraints

**Key method:**
```python
def analyze_training_impact(self, uncovered_request, near_match_resource):
    """
    Realistic training impact considering ALL constraints
    """
    # 1. Check qualification gap
    missing_quals = ...

    # 2. Simulate assignment with new qualification
    simulated_assignment = {...}

    # 3. Check against ALL enabled constraints
    for constraint_name in ENABLED_CONSTRAINTS:
        if constraint_name == "CP_02_qualification_matching":
            continue  # Training fixes this

        analyzer = self.analyzers[constraint_name]
        existing = self._get_existing_assignments(resource_id)

        check = analyzer.check_would_violate(
            simulated_assignment,
            existing,
            self.data,
            self.constraints
        )

        if check['would_violate']:
            # Training won't help - blocked by other constraints
            constraint_violations.append(check)

    return {
        'resource_id': resource_id,
        'add_qualifications': list(missing_quals),
        'request_enabled': request_id,
        'realistic': len(constraint_violations) == 0,
        'blocked_by': [v['constraint'] for v in constraint_violations],
        'recommendation': ...
    }
```

### 4. Create Main Orchestrator

**File:** `analysis/solution_analyzer.py`

**Purpose:** Coordinate all analyzers and generate comprehensive report

**Structure:**
```python
from .constraint_analyzers.lc_01_analyzer import LC_01_Analyzer
from .constraint_analyzers.lc_02_analyzer import LC_02_Analyzer
from .constraint_analyzers.lc_03_analyzer import LC_03_Analyzer
from .constraint_analyzers.lc_04_analyzer import LC_04_Analyzer
from .constraint_analyzers.cp_02_analyzer import CP_02_Analyzer
from .objective_analyzers.coverage_analyzer import CoverageAnalyzer
from .objective_analyzers.workload_analyzer import WorkloadAnalyzer
from .recommendations.training_analyzer import TrainingAnalyzer
import sys
sys.path.append('..')
from config import ENABLED_CONSTRAINTS, ENABLED_OBJECTIVES


class SolutionAnalyzer:
    """Main orchestrator for post-solve analysis"""

    def __init__(self, solution, data, constraints):
        self.solution = solution
        self.data = data
        self.constraints = constraints

        # Initialize analyzers
        self.constraint_analyzers = {
            'LC_01_max_weekly_hours': LC_01_Analyzer(),
            'LC_02_max_daily_hours_14h_span': LC_02_Analyzer(),
            'LC_03_max_absolute_daily_hours': LC_03_Analyzer(),
            'LC_04_max_continuous_work': LC_04_Analyzer(),
            'CP_02_qualification_matching': CP_02_Analyzer(),
        }

        self.objective_analyzers = {
            'maximize_coverage': CoverageAnalyzer(),
            'balance_workload': WorkloadAnalyzer(),
        }

        self.training_analyzer = TrainingAnalyzer(
            self.constraint_analyzers,
            data,
            constraints
        )

    def analyze(self):
        """Generate comprehensive analysis report"""
        report = {
            'metadata': {
                'status': self.solution.status,
                'objective_value': self.solution.objective_value,
                'solve_time': self.solution.solve_time,
                'timestamp': datetime.now().isoformat()
            },
            'constraint_violations': self._analyze_constraints(),
            'objective_performance': self._analyze_objectives(),
            'recommendations': self._generate_recommendations(),
            'summary': self._generate_summary()
        }

        return report

    def _analyze_constraints(self):
        """Analyze all enabled constraints"""
        results = {}

        for constraint_name in ENABLED_CONSTRAINTS:
            if constraint_name in self.constraint_analyzers:
                analyzer = self.constraint_analyzers[constraint_name]
                results[constraint_name] = analyzer.analyze_violations(
                    self.solution,
                    self.data,
                    self.constraints,
                    self.solution.violation_metadata
                )

        return results

    def _analyze_objectives(self):
        """Analyze all enabled objectives"""
        results = {}

        for objective_name in ENABLED_OBJECTIVES:
            if objective_name in self.objective_analyzers:
                analyzer = self.objective_analyzers[objective_name]
                results[objective_name] = analyzer.analyze_performance(
                    self.solution,
                    self.data,
                    self.constraints
                )

        return results

    def _generate_recommendations(self):
        """Generate actionable recommendations"""
        recommendations = []

        # Get coverage gaps
        coverage = self.objective_analyzers['maximize_coverage']
        coverage_result = coverage.analyze_performance(
            self.solution, self.data, self.constraints
        )

        # Analyze training opportunities
        if coverage_result['metrics']['uncovered_requests'] > 0:
            training_recs = self.training_analyzer.analyze_all_gaps(
                coverage_result
            )
            recommendations.extend(training_recs)

        # Add constraint-specific recommendations
        for constraint_name, analyzer in self.constraint_analyzers.items():
            if constraint_name in ENABLED_CONSTRAINTS:
                violation_analysis = analyzer.analyze_violations(
                    self.solution, self.data, self.constraints,
                    self.solution.violation_metadata
                )

                weight_suggestions = analyzer.suggest_weight_adjustment(
                    violation_analysis
                )

                if weight_suggestions['suggested_adjustments']:
                    recommendations.append({
                        'type': 'WEIGHT_ADJUSTMENT',
                        'constraint': constraint_name,
                        'suggestions': weight_suggestions['suggested_adjustments']
                    })

        return recommendations

    def _generate_summary(self):
        """Generate executive summary"""
        # Calculate key metrics
        coverage_pct = self.objective_analyzers['maximize_coverage'].analyze_performance(
            self.solution, self.data, self.constraints
        )['achievement_rate']

        total_violations = sum(
            result['total_violations']
            for result in self._analyze_constraints().values()
        )

        return {
            'coverage': f"{coverage_pct:.1f}%",
            'total_violations': total_violations,
            'status': 'EXCELLENT' if coverage_pct >= 95 and total_violations < 1000 else 'GOOD' if coverage_pct >= 80 else 'NEEDS IMPROVEMENT'
        }
```

### 5. Update main.py

**Add after solving:**

```python
# After: model.solve(time_limit)

# NEW: Run analysis
from analysis.solution_analyzer import SolutionAnalyzer
import json

if model.status in [cp_model.OPTIMAL, cp_model.FEASIBLE]:
    print("\n" + "="*60)
    print("RUNNING POST-SOLVE ANALYSIS")
    print("="*60)

    analyzer = SolutionAnalyzer(
        solution=model,
        data=preprocessed_data,
        constraints=constraint_values
    )

    analysis_report = analyzer.analyze()

    # Save analysis report
    with open('output/analysis_report.json', 'w') as f:
        json.dump(analysis_report, f, indent=2)

    print("\n‚úì Analysis complete: output/analysis_report.json")

    # Print summary
    print("\nANALYSIS SUMMARY:")
    print(f"  Coverage: {analysis_report['summary']['coverage']}")
    print(f"  Total Violations: {analysis_report['summary']['total_violations']}")
    print(f"  Status: {analysis_report['summary']['status']}")
```

## üìù Implementation Priority

1. **HIGH PRIORITY:**
   - Create `solution_analyzer.py` orchestrator
   - Create remaining constraint analyzers (LC_02, LC_03, CP_02)
   - Update `main.py` to run analysis

2. **MEDIUM PRIORITY:**
   - Create `workload_analyzer.py`
   - Create `training_analyzer.py`

3. **LOW PRIORITY:**
   - Create `capacity_analyzer.py` (optional)
   - Add more sophisticated recommendation logic

## üß™ Testing

Once implemented, test with:
```bash
cd /home/javiervel/clients/CFF/solver_v2
python main.py
```

Check outputs:
- `output/solution.json` - Solver solution
- `output/analysis_report.json` - Comprehensive analysis ‚≠ê NEW

## üìä Expected Analysis Output

```json
{
  "metadata": {...},
  "constraint_violations": {
    "LC_01_max_weekly_hours": {
      "total_violations": 25,
      "total_violation_amount": 45.5,
      "affected_resources": 8,
      "severity_breakdown": {"LOW": 15, "MEDIUM": 8, "HIGH": 2},
      "detailed_violations": [...]
    },
    "LC_02_max_daily_hours_14h_span": {...},
    ...
  },
  "objective_performance": {
    "maximize_coverage": {
      "achievement_rate": 86.0,
      "performance_category": "GOOD",
      "gaps": [
        {
          "gap_type": "QUALIFICATION_GAP",
          "description": "7 requests lack qualified resources",
          "recommendations": [
            "Train RES-INT-0025 on FORKLIFT (enables 3 requests)",
            "Hire resource with [NIGHT_SHIFT, FORKLIFT]"
          ]
        }
      ]
    },
    "balance_workload": {...}
  },
  "recommendations": [
    {
      "type": "TRAINING",
      "priority": "HIGH",
      "action": "Train RES-INT-0025 on FORKLIFT",
      "impact": "Enables 3 additional requests",
      "realistic": true
    },
    {
      "type": "WEIGHT_ADJUSTMENT",
      "constraint": "LC_01_max_weekly_hours",
      "suggestions": [...]
    }
  ],
  "summary": {
    "coverage": "86.0%",
    "total_violations": 11700,
    "status": "GOOD"
  }
}
```

## üéØ Success Criteria

‚úÖ Analysis system is complete when:
1. All constraint analyzers implemented
2. All objective analyzers implemented
3. Training analyzer considers ALL constraints
4. Orchestrator generates comprehensive JSON report
5. main.py runs analysis automatically
6. output/analysis_report.json contains actionable insights
