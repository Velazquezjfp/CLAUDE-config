"""
LC_01: Maximum Weekly Hours Analyzer
Analyzes violations of weekly hour limits (legal 50h, company 45h)
"""
from .base_analyzer import ConstraintAnalyzer
import sys
sys.path.append('../..')
from config import SCALING_FACTOR


class LC_01_Analyzer(ConstraintAnalyzer):
    """Analyzer for LC_01 (maximum weekly hours)"""

    def __init__(self):
        super().__init__(
            constraint_id='LC_01',
            constraint_name='max_weekly_hours'
        )

    def analyze_violations(self, solution, data, constraints, violation_metadata):
        """
        Analyze weekly hours violations

        Returns detailed breakdown of violations by resource and week
        """
        # Filter metadata for this constraint
        my_violations = [
            v for v in violation_metadata
            if v['constraint_id'] == 'LC_01'
        ]

        if not my_violations:
            return {
                "constraint_id": "LC_01",
                "constraint_name": "max_weekly_hours",
                "total_violations": 0,
                "total_violation_amount": 0.0,
                "affected_resources": 0,
                "severity_breakdown": {"LOW": 0, "MEDIUM": 0, "HIGH": 0},
                "detailed_violations": [],
                "message": "No violations detected"
            }

        # Group by resource
        violations_by_resource = {}
        total_violation_amount = 0.0

        for viol_meta in my_violations:
            # Get violation value from solver solution
            # Note: In a full implementation, we'd extract the actual value
            # For now, we'll use metadata to calculate potential violation
            resource_id = viol_meta['resource_id']
            week = viol_meta['week']

            # Calculate actual hours for this resource in this week
            actual_hours = self._calculate_actual_hours(
                solution, data, resource_id, viol_meta['week_idx']
            )

            # Only process if there's an actual violation
            company_limit = viol_meta['company_limit']
            if actual_hours <= company_limit:
                continue  # No violation

            violation_amount = actual_hours - company_limit
            total_violation_amount += violation_amount

            if resource_id not in violations_by_resource:
                violations_by_resource[resource_id] = []

            severity = self.classify_severity(
                violation_amount,
                viol_meta['legal_limit'],
                viol_meta['company_limit']
            )

            # Get only the assignments actually assigned to this resource in this week
            actual_assignments = self._get_resource_assignments_in_week(
                solution, data, resource_id, viol_meta['week_idx']
            )

            violations_by_resource[resource_id].append({
                'context': {
                    'week': self._format_week(week),
                    'week_idx': viol_meta['week_idx']
                },
                'legal_limit': viol_meta['legal_limit'],
                'company_limit': viol_meta['company_limit'],
                'actual_value': actual_hours,
                'violation_amount': violation_amount,
                'severity': severity,
                'affected_assignments': actual_assignments,
                'how_to_fix': self._generate_fix_suggestions(
                    viol_meta, actual_hours, violation_amount, data
                )
            })

        # Build severity breakdown
        severity_breakdown = {"LOW": 0, "MEDIUM": 0, "HIGH": 0}
        for resource_viols in violations_by_resource.values():
            for v in resource_viols:
                severity_breakdown[v['severity']] += 1

        # Format detailed violations
        detailed_violations = [
            {
                'resource_id': resource_id,
                'total_violations': len(viols),
                'total_violation_amount': sum(v['violation_amount'] for v in viols),
                'violations': viols
            }
            for resource_id, viols in violations_by_resource.items()
        ]

        return {
            "constraint_id": "LC_01",
            "constraint_name": "max_weekly_hours",
            "total_violations": sum(len(v) for v in violations_by_resource.values()),
            "total_violation_amount": round(total_violation_amount, 2),
            "affected_resources": len(violations_by_resource),
            "severity_breakdown": severity_breakdown,
            "detailed_violations": detailed_violations
        }

    def check_would_violate(self, simulated_assignment, existing_assignments,
                           data, constraints):
        """
        Check if adding this assignment would violate weekly hours
        """
        MIN_HOURS_LEGAL = constraints.get_legal_value('max_weekly_hours')
        MIN_HOURS_COMPANY = constraints.get_company_value('max_weekly_hours')

        # Find which week this assignment falls in
        from datetime import datetime
        sim_start = datetime.fromisoformat(simulated_assignment['start'])

        # Find the week
        week_idx = None
        for idx, week in enumerate(data.weeks):
            if week['start'] <= sim_start < week['end']:
                week_idx = idx
                break

        if week_idx is None:
            return {
                "would_violate": False,
                "violation_type": "none",
                "violation_amount": 0,
                "reason": "Assignment outside planning period"
            }

        # Calculate total hours in this week with new assignment
        total_hours = simulated_assignment['duration_hours']
        for existing in existing_assignments:
            exist_start = datetime.fromisoformat(existing['start'])
            if data.weeks[week_idx]['start'] <= exist_start < data.weeks[week_idx]['end']:
                total_hours += existing['duration_hours']

        # Check against limits
        if total_hours > MIN_HOURS_LEGAL:
            return {
                "would_violate": True,
                "violation_type": "legal",
                "violation_amount": total_hours - MIN_HOURS_LEGAL,
                "reason": f"Would exceed legal limit: {total_hours:.1f}h > {MIN_HOURS_LEGAL}h",
                "details": {
                    "week_idx": week_idx,
                    "total_hours": total_hours,
                    "legal_limit": MIN_HOURS_LEGAL
                }
            }
        elif total_hours > MIN_HOURS_COMPANY:
            return {
                "would_violate": True,
                "violation_type": "company",
                "violation_amount": total_hours - MIN_HOURS_COMPANY,
                "reason": f"Would exceed company limit: {total_hours:.1f}h > {MIN_HOURS_COMPANY}h",
                "details": {
                    "week_idx": week_idx,
                    "total_hours": total_hours,
                    "company_limit": MIN_HOURS_COMPANY
                }
            }

        return {
            "would_violate": False,
            "violation_type": "none",
            "violation_amount": 0,
            "reason": f"Within limits: {total_hours:.1f}h",
            "details": {
                "week_idx": week_idx,
                "total_hours": total_hours
            }
        }

    def suggest_weight_adjustment(self, violations):
        """Suggest weight adjustments"""
        total_viols = violations.get('total_violations', 0)
        total_amount = violations.get('total_violation_amount', 0)

        if total_viols == 0:
            return {
                "constraint_id": "LC_01",
                "current_weight": 1000,
                "suggested_adjustments": []
            }

        suggestions = []

        if total_viols > 100:
            suggestions.append({
                "new_weight": 1500,
                "expected_impact": "Stronger enforcement of weekly hours limit",
                "trade_offs": "May reduce coverage by 3-5% as more schedules become infeasible"
            })

        if total_amount > 200:
            suggestions.append({
                "new_weight": 2000,
                "expected_impact": "Very strong enforcement - minimize overtime",
                "trade_offs": "Could significantly reduce coverage, may need more resources"
            })

        if total_viols < 50 and total_amount < 100:
            suggestions.append({
                "new_weight": 700,
                "expected_impact": "More flexibility with weekly hours",
                "trade_offs": "May increase coverage by 2-3% but increases worker fatigue risk"
            })

        return {
            "constraint_id": "LC_01",
            "current_weight": 1000,
            "suggested_adjustments": suggestions
        }

    def _calculate_actual_hours(self, solution, data, resource_id, week_idx):
        """Calculate actual hours worked in a week"""
        # Get assignments - handle both attribute names for compatibility
        assignments = getattr(solution, 'solution_assignments', getattr(solution, 'assignments', []))

        total_hours_scaled = 0
        for assignment in assignments:
            if assignment['resource_id'] == resource_id:
                # Check if assignment is in this week
                req_id = assignment['demand_id']
                hours_in_week = data.get_task_hours_in_week(req_id, week_idx)
                total_hours_scaled += hours_in_week

        # Convert from scaled integers back to actual hours
        return total_hours_scaled / SCALING_FACTOR

    def _get_resource_assignments_in_week(self, solution, data, resource_id, week_idx):
        """Get list of request IDs assigned to this resource in this week"""
        assignments = getattr(solution, 'solution_assignments', getattr(solution, 'assignments', []))

        resource_assignments = []
        for assignment in assignments:
            if assignment['resource_id'] == resource_id:
                req_id = assignment['request_id']
                # Check if this request has hours in this week
                hours_in_week = data.get_task_hours_in_week(req_id, week_idx)
                if hours_in_week > 0:
                    resource_assignments.append(req_id)

        return resource_assignments

    def _format_week(self, week):
        """Format week tuple as readable string"""
        if isinstance(week, (list, tuple)) and len(week) == 2:
            start, end = week
            # Handle datetime objects
            if hasattr(start, 'strftime'):
                return f"Week of {start.strftime('%b %d')} - {end.strftime('%b %d, %Y')}"
            # Handle string representation
            return f"Week {start} to {end}"
        return str(week)

    def _generate_fix_suggestions(self, viol_meta, actual_hours, violation_amount, data):
        """Generate specific fix suggestions"""
        suggestions = []
        resource_id = viol_meta['resource_id']
        week = viol_meta['week']
        week_str = self._format_week(week)
        assignments = viol_meta['assignments_in_week']

        # Suggestion 1: Remove assignments to get under limit
        if assignments:
            # Find longest assignment
            longest_req = assignments[0]  # Simplified - would calculate actual durations
            suggestions.append(
                f"Remove assignment {longest_req} to reduce hours in {week_str}"
            )

        # Suggestion 2: Reassign to other resources
        suggestions.append(
            f"Reassign some {week_str} assignments to underutilized resources"
        )

        # Suggestion 3: Accept violation if minor
        if violation_amount < 3:
            suggestions.append(
                f"Accept violation ({violation_amount:.1f}h over) - within operational tolerance"
            )

        return suggestions
